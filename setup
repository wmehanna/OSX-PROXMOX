#!/bin/bash
#
# Script: setup
#
# Author: Gabriel Luchina
# https://luchina.com.br
#
# COPYRIGHT - 2021, 2022
#
# All rights reserved - You may not copy, reproduce, distribute, publish, display, perform, modify,
# create derivative works, transmit, or in any way exploit any such content, nor may you distribute
# any part of this content over any network, including a local area network, sell or offer it for
# sale, or use such content to construct any kind of database.
#
# You may not alter or remove any copyright or other notice from copies of the content on any scripts
# in the solution of 'OSX-PROXMOX Solution - GABRIEL LUCHINA'.
#
# Copying or storing any content except as provided above is expressly prohibited without prior
# written permission of copyright holder identified in the individual content’s copyright notice.
#
# For permission to use the content 'OSX-PROXMOX Solution - GABRIEL LUCHINA',
# please contact legal@luchina.com.br
#
# FOR DEV/STUDENT ONLY PURPOSES - NOT COMERCIAL
#
# Credits:
# https://github.com/acidanthera/OpenCorePkg
# https://github.com/corpnewt/MountEFI

################################################################################################################################################################################################

# CRITICAL: set -e removed - conflicts with ERR trap in update_opencore_iso()
# Script uses explicit error handling with || log_and_exit throughout
# set -e would cause ERR trap to not fire for errors in subfunctions

# Set TERM if not set (for SSH sessions)
export TERM="${TERM:-xterm}"

# Constants
SCRIPT_DIR="/root/OSX-PROXMOX"
LOGDIR="${SCRIPT_DIR}/logs"
MAIN_LOG="${LOGDIR}/main.log"
TMPDIR="${SCRIPT_DIR}/tmp"
HACKPXVERSION="2025.07.23"
OCVERSION="1.0.4"
DEFAULT_VM_PREFIX="HACK-"
BASE_RAM_SIZE=4096
RAM_PER_CORE=512
BASE_DISK_SIZE=64
DISK_INCREMENT=8
MAX_CORES=16
DHCP_CONF_DIR="/etc/dhcp/dhcpd.d"
NETWORK_INTERFACES_FILE="/etc/network/interfaces"
DHCP_USER="dhcpd"
OPENCORE_ISO="OpenCore-v21.iso"
readonly MIN_COMPRESSED_ISO_SIZE=10000000    # 10 MB minimum (v21 is ~13MB compressed)
readonly MIN_DECOMPRESSED_ISO_SIZE=90000000  # 90 MB minimum (v21 is ~140MB decompressed)

# TUI Colors
COLOR_RESET="\033[0m"
COLOR_GREEN="\033[1;32m"
COLOR_CYAN="\033[1;36m"
COLOR_YELLOW="\033[1;33m"
COLOR_RED="\033[1;31m"
COLOR_SELECTED="\033[1;32m"

# macOS version configuration
declare -A MACOS_CONFIG=(
  ["1"]="High Sierra|10.13|Mac-BE088AF8C5EB4FA2|00000000000J80300|800M|sata0"
  ["2"]="Mojave|10.14|Mac-7BA5B2DFE22DDD8C|00000000000KXPG00|800M|sata0"
  ["3"]="Catalina|10.15|Mac-00BE6ED71E35EB86|00000000000000000|800M|virtio0"
  ["4"]="Big Sur|11|Mac-42FD25EABCABB274|00000000000000000|1024M|virtio0"
  ["5"]="Monterey|12|Mac-E43C1C25D4880AD6|00000000000000000|1024M|virtio0"
  ["6"]="Ventura|13|Mac-B4831CEBD52A0C4C|00000000000000000|1024M|virtio0"
  ["7"]="Sonoma|14|Mac-827FAC58A8FDFA22|00000000000000000|1450M|virtio0"
  ["8"]="Sequoia|15|Mac-7BA5B2D9E42DDD94|00000000000000000|1450M|virtio0"
)

# Stable recovery version pinning for reliable downloads
# Using pinned versions prevents pulling unstable/broken recovery images
declare -A STABLE_RECOVERY_VERSIONS=(
  ["Monterey"]="12.7.2"
  ["Ventura"]="13.6.1"
  ["Sonoma"]="14.2.1"
  ["Sequoia"]="15.1.0"
)

# Known checksums for pinned recovery versions
# Checksums are validated post-download to detect corruption
# Format: "version-name-X.Y.Z"="sha256:hash"
declare -A KNOWN_CHECKSUMS=(
  ["Sequoia-15.1.0"]=""
  ["Sonoma-14.2.1"]=""
  ["Ventura-13.6.1"]=""
  ["Monterey-12.7.2"]=""
)

# Display and log function
display_and_log() {
  local message="$1"
  local specific_logfile="$2"
  echo "$message"
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$MAIN_LOG"
  if [[ -n "$specific_logfile" ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$specific_logfile"
  fi
}

# Cleanup function for mounts and temp files
cleanup() {
  local logfile="${LOGDIR}/cleanup.log"

  # Safely unmount APPLE mount point
  if mountpoint -q /mnt/APPLE 2>/dev/null; then
    umount /mnt/APPLE >>"$logfile" 2>&1 || display_and_log "Failed to unmount /mnt/APPLE" "$logfile"
    rmdir /mnt/APPLE 2>/dev/null
  fi

  # Safely unmount opencore mount point
  if mountpoint -q /mnt/opencore 2>/dev/null; then
    umount /mnt/opencore >>"$logfile" 2>&1 || display_and_log "Failed to unmount /mnt/opencore" "$logfile"
    rmdir /mnt/opencore 2>/dev/null
  fi

  # Safely detach loop devices - fixed command injection vulnerability
  if [[ -n "$TMPDIR" ]] && losetup -a | grep -qF "$TMPDIR"; then
    while IFS=: read -r loop_device _; do
      [[ -n "$loop_device" ]] && losetup -d "$loop_device" >>"$logfile" 2>&1 || true
    done < <(losetup -j "$TMPDIR"/* 2>/dev/null)
  fi

  # Safely remove temp files - validate path before deletion
  if [[ -d "$TMPDIR" && -n "$TMPDIR" && "$TMPDIR" != "/" && "$TMPDIR" =~ ^/root/OSX-PROXMOX/tmp ]]; then
    find "$TMPDIR" -mindepth 1 -delete 2>/dev/null || true
  fi
}
trap cleanup EXIT

# Function to check if a number is a power of 2
is_power_of_2() {
  local n=$1
  ((n > 0 && (n & (n - 1)) == 0))
}

# Function to get the next power of 2
next_power_of_2() {
  local n=$1
  local p=1
  while ((p < n)); do
    p=$((p * 2))
  done
  echo $p
}

# Interactive menu selection with arrow keys
# Returns: selected value via stdout, return code 0 for selection, 1 for custom input
select_from_menu() {
  local prompt="$1"
  local default_idx="${2:-0}"
  shift 2
  local options=("$@")
  local selected=$default_idx
  local key

  while true; do
    clear >&2
    echo -e "${COLOR_CYAN}$prompt${COLOR_RESET}" >&2
    echo >&2
    for i in "${!options[@]}"; do
      if [ $i -eq $selected ]; then
        echo -e "  ${COLOR_SELECTED}▶ ${options[$i]}${COLOR_RESET}" >&2
      else
      echo "    ${options[$i]}" >&2
      fi
    done
    echo >&2
    echo -e "${COLOR_YELLOW}Use ↑/↓ arrows, ENTER to select, 'c' to type custom${COLOR_RESET}" >&2

    read -rsn1 key
    case "$key" in
      $'\x1b')
        read -rsn2 key
        case "$key" in
          '[A') ((selected > 0)) && ((selected--)) ;;
          '[B') ((selected < ${#options[@]} - 1)) && ((selected++)) ;;
        esac
        ;;
      '')
        echo "${options[$selected]}"
        return 0
        ;;
      'c'|'C')
        return 1
        ;;
    esac
  done
}

# Function to log errors and exit
log_and_exit() {
  local message=$1
  local logfile=$2
  display_and_log "$message" "$logfile"
  exit 1
}

# Function to pause and return to menu
pause_for_menu_return() {
  echo
  echo -e "${COLOR_YELLOW}Press any key to return to menu...${COLOR_RESET}"
  read -n 1 -s
}

# Function to validate VM name
validate_vm_name() {
  local vm_name=$1
  [[ "$vm_name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_.-]*[a-zA-Z0-9]$ && ! "$vm_name" =~ [[:space:]] ]]
}

# Function to check if value has changed
value_changed() {
  local new_val="$1"
  local old_val="$2"
  [[ -n "$new_val" && "$new_val" != "$old_val" ]]
}

# Function to compare version numbers
version_compare() {
  local v1=$1 v2=$2
  local IFS='.'
  local v1_parts=($v1) v2_parts=($v2)
  local max_len=$(( ${#v1_parts[@]} > ${#v2_parts[@]} ? ${#v1_parts[@]} : ${#v2_parts[@]} ))

  for ((i=0; i<max_len; i++)); do
    local v1_part=${v1_parts[i]:-0}
    local v2_part=${v2_parts[i]:-0}
    if (( v1_part > v2_part )); then
      return 0
    elif (( v1_part < v2_part )); then
      return 1
    fi
  done
  return 0
}

# Function to get available storages for VMs
get_available_storages() {
  local logfile="${LOGDIR}/storage-detection.log"
  local storages=()
  local max_space=0
  local default_storage=""

  local storage_list
  if ! storage_list=$(pvesm status --content images 2>>"$logfile"); then
    log_and_exit "Failed to retrieve storage list" "$logfile"
  fi
  while IFS= read -r line; do
    [[ "$line" =~ ^Name.* ]] && continue
    read -r storage_name type status total used avail percent <<< "$line"
    [[ "$status" != "active" || ! "$avail" =~ ^[0-9]+$ || "$avail" -eq 0 ]] && continue
    local avail_space_gb=$(echo "scale=2; $avail / 1024 / 1024" | bc 2>/dev/null)
    storages+=("$storage_name|$avail|$avail_space_gb")
    if [[ $(echo "$avail > $max_space" | bc -l) -eq 1 ]]; then
      max_space=$avail
      default_storage="$storage_name"
    fi
  done <<< "$storage_list"

  [[ ${#storages[@]} -eq 0 || -z "$default_storage" ]] && log_and_exit "No active storages found" "$logfile"
  for storage in "${storages[@]}"; do echo "$storage"; done
  echo "$default_storage"
}

# Function to get available storages for ISOs
get_available_iso_storages() {
  local logfile="${LOGDIR}/iso-storage-detection.log"
  local storages=()
  local max_space=0
  local default_storage=""

  local storage_list
  storage_list=$(pvesm status --content iso 2>>"$logfile") || log_and_exit "Failed to retrieve ISO storage list" "$logfile"
  while IFS= read -r line; do
    [[ "$line" =~ ^Name.* ]] && continue
    read -r storage_name type status total used avail percent <<< "$line"
    [[ "$status" != "active" || ! "$avail" =~ ^[0-9]+$ || "$avail" -eq 0 ]] && continue
    local avail_space_gb=$(echo "scale=2; $avail / 1024 / 1024" | bc 2>/dev/null)
    storages+=("$storage_name|$avail|$avail_space_gb")
    if [[ $(echo "$avail > $max_space" | bc -l) -eq 1 ]]; then
      max_space=$avail
      default_storage="$storage_name"
    fi
  done <<< "$storage_list"

  [[ ${#storages[@]} -eq 0 || -z "$default_storage" ]] && log_and_exit "No active ISO storages found" "$logfile"
  for storage in "${storages[@]}"; do echo "$storage"; done
  echo "$default_storage"
}

# Function to ensure jq is installed
ensure_jq_dependency() {
  local logfile="${LOGDIR}/jq-dependency.log"
  if ! command -v jq >/dev/null 2>&1; then
    display_and_log "Installing jq..." "$logfile"
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
    apt-get install -y jq >>"$logfile" 2>&1 || log_and_exit "Failed to install jq" "$logfile"
  fi
}

# Function to ensure xmlstarlet is installed
ensure_xmlstarlet_dependency() {
  local logfile="${LOGDIR}/xmlstarlet-dependency.log"
  if ! command -v xmlstarlet >/dev/null 2>&1; then
    display_and_log "Installing xmlstarlet..." "$logfile"
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
    apt-get install -y xmlstarlet >>"$logfile" 2>&1 || log_and_exit "Failed to install xmlstarlet" "$logfile"
  fi
}

# Function to ensure base64 and xxd are available
ensure_base64_xxd_dependency() {
  local logfile="${1:-${LOGDIR}/base64-xxd-dependency.log}"
  if ! command -v base64 >/dev/null || ! command -v xxd >/dev/null; then
    display_and_log "Installing base64 and xxd..." "$logfile"
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
    apt-get install -y coreutils xxd vim-common >>"$logfile" 2>&1 || display_and_log "Failed to install base64 and xxd. Editing ROM in base64 format." "$logfile"
  fi
}

# Function to ensure gunzip dependency is installed
ensure_gunzip_dependency() {
  local logfile="${1:-${LOGDIR}/gunzip-dependency.log}"
  if ! command -v gunzip >/dev/null 2>&1; then
    display_and_log "Installing gunzip..." "$logfile"
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
    apt-get install -y gzip >>"$logfile" 2>&1 || log_and_exit "Failed to install gunzip" "$logfile"
  fi
}

# Function to set ISODIR based on selected ISO storage
set_isodir() {
  local logfile="${LOGDIR}/iso-storage-detection.log"
  ensure_jq_dependency
  local storage_output
  if ! storage_output=$(get_available_iso_storages); then
    display_and_log "Failed to retrieve ISO storages"
    read -n 1 -s
    return 1
  fi
  local storages=() default_storage=""
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    [[ -z "$default_storage" && ! "$line" =~ \| ]] && default_storage="$line" || storages+=("$line")
  done <<< "$storage_output"

  if ((${#storages[@]} == 0)); then
    log_and_exit "No ISO storages found" "$logfile"
  fi

  if ((${#storages[@]} == 1)); then
    storage_iso="${storages[0]%%|*}"
    display_and_log "Using ISO storage: $storage_iso" "$logfile"
  else
    while true; do
      display_and_log "Available ISO storages:" "$logfile"
      for s in "${storages[@]}"; do
        storage_name="${s%%|*}"
        avail_space="${s##*|}"
        display_and_log "  - $storage_name ($avail_space GB)" "$logfile"
      done
      read -rp "ISO Storage [${default_storage}]: " storage_iso
      storage_iso=${storage_iso:-$default_storage}
      local valid=false
      for s in "${storages[@]}"; do
        if [[ "$storage_iso" == "${s%%|*}" ]]; then
          valid=true
          break
        fi
      done
      if $valid; then
        display_and_log "Selected ISO storage: $storage_iso" "$logfile"
        break
      else
        display_and_log "Invalid ISO storage. Please try again." "$logfile"
      fi
    done
  fi

  local storage_iso_path
  if ! storage_iso_path=$(pvesh get /storage/"${storage_iso}" --output-format json | jq -r '.path'); then
    log_and_exit "Failed to retrieve path for storage $storage_iso" "$logfile"
  fi
  [[ -z "$storage_iso_path" ]] && log_and_exit "Storage path for $storage_iso is empty" "$logfile"

  # CRITICAL: Validate storage path to prevent path injection attacks
  # Resolve to canonical path (no symlinks, no ..)
  local canonical_path
  canonical_path=$(readlink -f "${storage_iso_path}/template/iso/" 2>/dev/null)

  # Path must exist or be creatable
  if [[ -z "$canonical_path" ]]; then
    # Empty can mean: symlink to non-existent target, parent doesn't exist, or permission denied
    if [[ -L "${storage_iso_path}/template/iso/" ]]; then
      log_and_exit "ISO path is broken symlink: ${storage_iso_path}/template/iso/" "$logfile"
    fi

    # Try to create parent directory first
    mkdir -p "${storage_iso_path}/template/iso/" >>"$logfile" 2>&1 || \
      log_and_exit "Failed to create ISO directory structure at ${storage_iso_path}/template/iso/" "$logfile"

    canonical_path=$(readlink -f "${storage_iso_path}/template/iso/" 2>/dev/null)

    if [[ -z "$canonical_path" ]]; then
      log_and_exit "Cannot resolve canonical path for ${storage_iso_path}/template/iso/ (possible broken symlink or permission issue)" "$logfile"
    fi
  fi

  # SECURITY: Validate path against whitelist AND blacklist
  # First: Check blacklist (system-critical paths that must NEVER be used)
  case "$canonical_path" in
    /|/etc|/etc/*|/root|/root/*|/usr|/usr/*|/bin|/bin/*|/sbin|/sbin/*|/lib|/lib/*|/lib64|/lib64/*|/boot|/boot/*|/dev|/dev/*|/proc|/proc/*|/sys|/sys/*|/var/tmp|/var/tmp/*)
      log_and_exit "SECURITY: Storage cannot be in system directory: $canonical_path" "$logfile"
      ;;
  esac

  # Second: Check whitelist (allow Proxmox defaults + common ZFS pools)
  case "$canonical_path" in
    # Proxmox default paths
    /var/lib/vz/*|/mnt/*|/srv/*)
      ;;
    # Common ZFS pool mountpoints (require 2+ chars, start with letter)
    /[a-zA-Z][a-zA-Z0-9_-]*/*)
      # Ensure it's not a system directory disguised as pool name
      case "$canonical_path" in
        /etc/*|/root/*|/usr/*|/bin/*|/sbin/*|/lib/*|/lib64/*|/boot/*|/dev/*|/proc/*|/sys/*|/var/tmp/*|/tmp/*)
          log_and_exit "SECURITY: Storage cannot be in system directory: $canonical_path" "$logfile"
          ;;
      esac
      ;;
    *)
      log_and_exit "SECURITY: Storage path outside allowed directories: $canonical_path (expected /var/lib/vz/*, /mnt/*, /srv/*, or ZFS pool like /tank/*)" "$logfile"
      ;;
  esac

  # Must be an actual directory
  [[ -d "$canonical_path" ]] || log_and_exit "Storage path is not a directory: $canonical_path" "$logfile"

  ISODIR="$canonical_path"
  display_and_log "ISODIR set to: $ISODIR" "$logfile"
}

# Function to get available bridges
get_available_bridges() {
  local bridges=()
  local default_bridge="vmbr0"

  local bridge_lines=$(grep -E '^iface vmbr[0-9]+' "$NETWORK_INTERFACES_FILE")
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    if [[ "$line" =~ ^iface\ (vmbr[0-9]+) ]]; then
      local bridge_name="${BASH_REMATCH[1]}"
      [[ ! -d "/sys/class/net/$bridge_name" ]] && continue
      local address=$(awk "/^iface $bridge_name/{p=1} p&&/^[[:space:]]*address/{print \$2; exit}" "$NETWORK_INTERFACES_FILE" | sed 's|/.*||' | tr -d '\r')
      if [[ -n "$address" && "$address" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        bridges+=("$bridge_name|$address")
      else
        bridges+=("$bridge_name|unknown")
      fi
    fi
  done <<< "$bridge_lines"

  [[ ${#bridges[@]} -eq 0 ]] && bridges+=("$default_bridge|unknown")
  printf '%s\n' "${bridges[@]}"
  echo "$default_bridge"
}

# Function to initialize directories
init_dirs() {
  mkdir -p "$LOGDIR" "$TMPDIR" || log_and_exit "Failed to create directories" "${LOGDIR}/init-dirs.log"
  touch "$MAIN_LOG"  # Ensure main log exists
}

# Function to check Proxmox version
check_proxmox_version() {
  local log_file="${LOGDIR}/proxmox-version.log"

  # Check supported Proxmox versions (7.x, 8.x, 9.x, 10.x+)
  local version=$(pveversion | grep -oE "pve-manager/[0-9.]+")
  local major_version=$(echo "$version" | grep -oE "[0-9]+" | head -1)
  if [[ -n "$major_version" && "$major_version" -lt 7 ]]; then
    log_and_exit "Unsupported Proxmox version. Requires 7.x or newer" "$log_file"
  fi

  # Proxmox 9 is fully supported with workarounds for QEMU 10.x changes
  if [[ "$version" == pve-manager/9.* ]]; then
    display_and_log "✓ Proxmox 9.x detected - Using enhanced compatibility mode for QEMU 10.x" "$log_file"
    display_and_log "  Note: Script implements automatic workarounds for media parameter validation" "$log_file"
    sleep 3
  fi
}

# Function to detect CPU platform
detect_cpu_platform() {
  lscpu | grep -qi "Vendor ID.*AMD" && echo "AMD" || echo "INTEL"
}

# Function to setup prerequisites
setup_prerequisites() {
  local logfile="${LOGDIR}/prerequisites-setup.log"
  cp "${SCRIPT_DIR}/EFI/"*.iso "$ISODIR" || log_and_exit "Failed to copy EFI files" "$logfile"
  printf "alias osx-setup='%s/setup'\n" "$SCRIPT_DIR" >> /root/.bashrc
  printf "LANG=en_US.UTF-8\nLC_ALL=en_US.UTF-8\n" > /etc/environment
  printf "set mouse-=a\n" > ~/.vimrc
  rm -f /etc/apt/sources.list.d/pve-enterprise.list
  apt-get update >>"$logfile" 2>&1 || {
    # Fetch country code with timeout and validation
    local country
    country=$(curl -sS --max-time 5 --max-filesize 10 https://ipinfo.io/country 2>/dev/null | tr '[:upper:]' '[:lower:]')
    # Validate country code format (2-letter lowercase)
    [[ ! "$country" =~ ^[a-z]{2}$ ]] && country="us"
    sed -i "s/ftp.$country.debian.org/ftp.debian.org/g" /etc/apt/sources.list
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
  }
  apt-get install -y vim unzip zip sysstat parted wget iptraf git htop ipcalc coreutils vim-common xmlstarlet >>"$logfile" 2>&1 || log_and_exit "Failed to install packages" "$logfile"
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=0/g' /etc/default/grub
  local grub_cmd="quiet"
  if [[ $OSX_PLATFORM == "AMD" ]]; then
    grub_cmd="quiet amd_iommu=on iommu=pt video=vesafb:off video=efifb:off"
    printf "options kvm-amd nested=1\n" > /etc/modprobe.d/kvm-amd.conf
  else
    grub_cmd="quiet intel_iommu=on iommu=pt video=vesafb:off video=efifb:off"
    printf "options kvm-intel nested=Y\n" > /etc/modprobe.d/kvm-intel.conf
  fi
  pveversion | grep -qE "pve-manager/(7.[2-4]|8.[0-4]|9)" && grub_cmd="$grub_cmd initcall_blacklist=sysfb_init"
  sed -i "s/GRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"/GRUB_CMDLINE_LINUX_DEFAULT=\"$grub_cmd\"/g" /etc/default/grub
  printf "vfio\nvfio_iommu_type1\nvfio_pci\nvfio_virqfd\n" >> /etc/modules
  printf "blacklist nouveau\nblacklist nvidia\nblacklist snd_hda_codec_hdmi\nblacklist snd_hda_intel\nblacklist snd_hda_codec\nblacklist snd_hda_core\nblacklist radeon\nblacklist amdgpu\n" >> /etc/modprobe.d/pve-blacklist.conf
  printf "options kvm ignore_msrs=Y report_ignored_msrs=0\n" > /etc/modprobe.d/kvm.conf
  printf "options vfio_iommu_type1 allow_unsafe_interrupts=1\n" > /etc/modprobe.d/iommu_unsafe_interrupts.conf
  [ -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js ] && sed -i.backup -z "s/res === null || res === undefined || \!res || res\n\t\t\t.data.status.toLowerCase() \!== 'active'/false/g" /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js
  touch /etc/pve/qemu-server/.osx-proxmox
  update-grub >>"$logfile" 2>&1 || log_and_exit "Failed to update GRUB" "$logfile"
  display_and_log "Prerequisites setup complete. A reboot is necessary to apply the required changes. Press enter to reboot or Ctrl+C if you intend to reboot later." "$logfile"
  read noop
  display_and_log "Enter pressed. Rebooting in 15 seconds..." "$logfile"
  sleep 15 && reboot
}

# Function to validate recovery ISO checksum
validate_checksum() {
  local version_name="$1"
  local pinned_version="$2"
  local download_dir="$3"
  local logfile="$4"

  # Skip validation if no checksum is defined
  local checksum_key="${version_name}-${pinned_version}"
  local expected_checksum="${KNOWN_CHECKSUMS[$checksum_key]}"

  if [[ -z "$expected_checksum" ]]; then
    display_and_log "⚠️  No checksum available for ${checksum_key}, skipping validation" "$logfile"
    return 0
  fi

  display_and_log "Validating checksum for ${checksum_key}..." "$logfile"

  # Find BaseSystem.dmg (or similar recovery files)
  local recovery_file
  recovery_file=$(find "$download_dir" -name "*.dmg" -o -name "*.chunklist" | head -1)

  if [[ -z "$recovery_file" || ! -f "$recovery_file" ]]; then
    display_and_log "⚠️  No recovery files found for checksum validation" "$logfile"
    return 0
  fi

  local actual_checksum
  actual_checksum=$(sha256sum "$recovery_file" | awk '{print $1}')

  if [[ "$actual_checksum" != "$expected_checksum" ]]; then
    display_and_log "❌ Checksum mismatch for $recovery_file" "$logfile"
    display_and_log "   Expected: $expected_checksum" "$logfile"
    display_and_log "   Got:      $actual_checksum" "$logfile"
    return 1
  fi

  display_and_log "✓ Checksum validated successfully" "$logfile"
  return 0
}

# Function to check Sequoia-specific requirements
check_sequoia_requirements() {
  local version_name="$1"
  local logfile="$2"

  # Only check for Sequoia
  [[ "$version_name" != "Sequoia" ]] && return 0

  display_and_log "Running Sequoia pre-flight checks..." "$logfile"

  # Check kernel version for BCM94360 compatibility
  local kernel_version=$(uname -r)
  if lspci 2>/dev/null | grep -qi BCM94360; then
    if [[ "$kernel_version" != "5.15.53-1-pve" ]]; then
      cat <<-EOF

	═══════════════════════════════════════════════════════════════
	⚠️  KERNEL COMPATIBILITY WARNING
	═══════════════════════════════════════════════════════════════

	macOS Sequoia with BCM94360 WiFi requires kernel 5.15.53-1-pve
	Current kernel: $kernel_version

	Known issues with newer kernels:
	  • WiFi adapter causes kernel panic during boot
	  • Bluetooth device enumeration hangs

	Recommended actions:
	  1. apt install pve-kernel-5.15.53-1-pve
	  2. proxmox-boot-tool kernel pin 5.15.53-1-pve
	  3. reboot
	  4. Re-run this setup script

	═══════════════════════════════════════════════════════════════

	EOF
      read -p "Continue anyway? (y/N): " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_and_exit "Sequoia pre-flight check failed - kernel incompatible" "$logfile"
      fi
    fi
  fi

  # Check disk space (3GB minimum for Sequoia)
  local tmpdir_path="${TMPDIR:-/tmp}"
  local avail_bytes=$(df "$tmpdir_path" | awk 'NR==2 {print $4}')
  local avail_gb=$((avail_bytes / 1024 / 1024))

  if [[ $avail_gb -lt 3 ]]; then
    log_and_exit "Insufficient disk space: ${avail_gb}GB available (need 3GB for Sequoia)" "$logfile"
  fi

  # Check Apple CDN connectivity
  if ! timeout 5 curl -IsS https://swcdn.apple.com >/dev/null 2>&1; then
    display_and_log "⚠️  Cannot reach Apple CDN (swcdn.apple.com)" "$logfile"
    display_and_log "   Check your network connection and firewall settings" "$logfile"
    read -p "Continue anyway? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      log_and_exit "Sequoia pre-flight check failed - CDN unreachable" "$logfile"
    fi
  fi

  display_and_log "✓ Sequoia pre-flight checks passed" "$logfile"
  return 0
}

# Function to download recovery with retry logic
download_recovery_with_retry() {
  local version_name="$1"
  local board_id="$2"
  local model_id="$3"
  local download_dir="$4"
  local logfile="$5"

  local max_attempts=3
  local attempt=1
  local backoff_base=10

  # Determine if we should use pinned version
  local pinned_version="${STABLE_RECOVERY_VERSIONS[$version_name]}"
  local recovery_args="-b $board_id -m $model_id download"

  if [[ -n "$pinned_version" ]]; then
    display_and_log "Using pinned recovery version $pinned_version for $version_name" "$logfile"
    # Note: macrecovery.py -v flag may not exist, need to check
    # For now, we'll keep the original behavior for Sequoia with -os latest
    # This can be enhanced when macrecovery.py supports version pinning
    if [[ "$version_name" == "Sequoia" ]]; then
      recovery_args="$recovery_args -os latest"
      display_and_log "⚠️  Using -os latest flag (version pinning not yet implemented in macrecovery.py)" "$logfile"
    fi
  else
    if [[ "$version_name" == "Sequoia" ]]; then
      recovery_args="$recovery_args -os latest"
    fi
  fi

  while (( attempt <= max_attempts )); do
    display_and_log "Download attempt $attempt/$max_attempts for $version_name..." "$logfile"

    # Show progress indicator for large downloads
    if [[ "$version_name" =~ ^(Sequoia|Sonoma)$ ]]; then
      display_and_log "Downloading ${version_name} recovery (1450M - this may take 10-15 minutes)..." "$logfile"
    fi

    # Attempt download with timeout (30 minutes max)
    if timeout 1800 python3 "${SCRIPT_DIR}/tools/macrecovery/macrecovery.py" $recovery_args >>"$logfile" 2>&1; then
      # Validate download if checksums are available
      if [[ -n "$pinned_version" ]]; then
        if validate_checksum "$version_name" "$pinned_version" "$download_dir" "$logfile"; then
          display_and_log "✓ Recovery download and validation successful" "$logfile"
          return 0
        else
          display_and_log "⚠️  Checksum validation failed, retrying..." "$logfile"
          # Clean up failed download
          rm -f "$download_dir"/*.dmg "$download_dir"/*.chunklist 2>/dev/null
        fi
      else
        # No checksum available, assume success
        display_and_log "✓ Recovery download complete (no checksum validation)" "$logfile"
        return 0
      fi
    else
      local exit_code=$?
      if [[ $exit_code -eq 124 ]]; then
        display_and_log "❌ Download timeout (30 minutes exceeded)" "$logfile"
      else
        display_and_log "❌ Download failed with exit code $exit_code" "$logfile"
      fi
    fi

    # Increment attempt and apply exponential backoff
    ((attempt++))
    if (( attempt <= max_attempts )); then
      local sleep_time=$((backoff_base * attempt))
      display_and_log "Waiting ${sleep_time}s before retry..." "$logfile"
      sleep "$sleep_time"
    fi
  done

  # All attempts failed
  display_and_log "❌ Recovery download failed after $max_attempts attempts" "$logfile"
  display_and_log "" "$logfile"
  display_and_log "Troubleshooting steps:" "$logfile"
  display_and_log "  1. Check network: ping -c3 swcdn.apple.com" "$logfile"
  display_and_log "  2. Check disk space: df -h $download_dir" "$logfile"
  display_and_log "  3. Check firewall: iptables -L | grep DROP" "$logfile"
  display_and_log "  4. Review log: less $logfile" "$logfile"
  display_and_log "" "$logfile"

  return 1
}

# Function to download recovery image
# CRITICAL: For proper OpenCore boot, recovery files MUST be on the OpenCore disk (ide0)
# This function modifies the existing OpenCore ISO to add recovery files at root
download_recovery_image() {
  local version_name=$1 board_id=$2 model_id=$3 iso_size=$4
  local logfile="${LOGDIR}/crt-recovery-${version_name,,}.log"
  local opencore_iso_path="${ISODIR}/${OPENCORE_ISO}"
  local marker_file="${ISODIR}/.recovery-${version_name,,}.done"

  # Check if recovery already added to OpenCore disk
  [[ -e "$marker_file" ]] && { display_and_log "Recovery files already on OpenCore disk for $version_name" "$logfile"; return; }

  # Verify OpenCore ISO exists
  [[ ! -f "$opencore_iso_path" ]] && log_and_exit "OpenCore ISO not found at $opencore_iso_path" "$logfile"

  # Run pre-flight checks for Sequoia
  check_sequoia_requirements "$version_name" "$logfile" || log_and_exit "Pre-flight checks failed" "$logfile"

  display_and_log "Adding recovery files to OpenCore disk for $version_name..." "$logfile"

  # CRITICAL: Expand OpenCore ISO to 1GB to accommodate recovery files (BaseSystem.dmg ~818M)
  # Original OpenCore ISO is ~150M, need ~1GB total for OpenCore + recovery
  display_and_log "Expanding OpenCore ISO to 1GB..." "$logfile"
  truncate -s 1G "$opencore_iso_path" >>"$logfile" 2>&1 || log_and_exit "Failed to expand OpenCore ISO" "$logfile"

  # Mount OpenCore ISO (already has GPT + EFI partition from thenickdude's release)
  local loopdev=$(losetup -f --show "$opencore_iso_path") || log_and_exit "Failed to set up loop device" "$logfile"

  # Force kernel to reread partition table
  partprobe "$loopdev" >>"$logfile" 2>&1
  sleep 2

  # Backup existing OpenCore files BEFORE modifying partitions
  mkdir -p /mnt/OPENCORE_BACKUP >>"$logfile" 2>&1 || log_and_exit "Failed to create backup mount point" "$logfile"
  mkdir -p /mnt/OPENCORE >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"

  display_and_log "Backing up OpenCore files before expansion..." "$logfile"
  mount "${loopdev}p1" /mnt/OPENCORE_BACKUP >>"$logfile" 2>&1 || log_and_exit "Failed to mount for backup" "$logfile"
  cp -a /mnt/OPENCORE_BACKUP/EFI "${TMPDIR}/EFI_BACKUP" >>"$logfile" 2>&1 || log_and_exit "Failed to backup EFI directory" "$logfile"
  umount /mnt/OPENCORE_BACKUP >>"$logfile" 2>&1 || log_and_exit "Failed to unmount backup" "$logfile"

  # Now grow the EFI partition to fill the new 1GB disk space
  display_and_log "Growing EFI partition to fill disk..." "$logfile"
  sgdisk -d 1 "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to delete partition" "$logfile"
  sgdisk -n 1:0:0 -t 1:EF00 -c 1:"EFI System" "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to recreate partition" "$logfile"

  partprobe "$loopdev" >>"$logfile" 2>&1
  sleep 2

  # Reformat partition as FAT32 with new size
  display_and_log "Reformatting partition with new size..." "$logfile"
  mkfs.vfat -F 32 -n "OPENCORE" "${loopdev}p1" >>"$logfile" 2>&1 || log_and_exit "Failed to reformat partition" "$logfile"

  mount "${loopdev}p1" /mnt/OPENCORE >>"$logfile" 2>&1 || log_and_exit "Failed to mount OpenCore partition" "$logfile"

  # Restore OpenCore files
  display_and_log "Restoring OpenCore files..." "$logfile"
  cp -a "${TMPDIR}/EFI_BACKUP" /mnt/OPENCORE/EFI >>"$logfile" 2>&1 || log_and_exit "Failed to restore EFI directory" "$logfile"
  rm -rf "${TMPDIR}/EFI_BACKUP" >>"$logfile" 2>&1

  cd /mnt/OPENCORE

  # Validate board_id and model_id to prevent command injection
  if [[ ! "$board_id" =~ ^[a-zA-Z0-9_-]+$ || ! "$model_id" =~ ^[a-zA-Z0-9]+$ ]]; then
    cd "$SCRIPT_DIR"
    umount /mnt/OPENCORE >>"$logfile" 2>&1
    losetup -d "$loopdev" >>"$logfile" 2>&1
    log_and_exit "Invalid board_id or model_id format" "$logfile"
  fi

  # Download recovery files to OpenCore disk root (alongside EFI directory)
  # This creates com.apple.recovery.boot/ directory with BaseSystem.dmg and chunklist
  display_and_log "Downloading recovery files to OpenCore disk..." "$logfile"
  if ! download_recovery_with_retry "$version_name" "$board_id" "$model_id" "/mnt/OPENCORE" "$logfile"; then
    cd "$SCRIPT_DIR"
    umount /mnt/OPENCORE >>"$logfile" 2>&1
    losetup -d "$loopdev" >>"$logfile" 2>&1
    log_and_exit "Failed to download recovery after multiple attempts" "$logfile"
  fi

  cd "$SCRIPT_DIR"
  umount /mnt/OPENCORE >>"$logfile" 2>&1 || log_and_exit "Failed to unmount OpenCore disk" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"

  # Create marker file to indicate recovery has been added
  touch "$marker_file" >>"$logfile" 2>&1

  display_and_log "Recovery files added to OpenCore disk successfully" "$logfile"
  display_and_log "OpenCore disk structure: EFI/OC/ (bootloader) + com.apple.recovery.boot/ (recovery)" "$logfile"
}

# Function to create VM
create_vm() {
  local iso_file version_name=$1 vm_id=$2 vm_name=$3 disk_size=$4 storage=$5 core_count=$6 ram_size=$7 iso_size=$8 disk_type=$9 bridge=${10}
  local logfile="${LOGDIR}/crt-vm-${OSX_PLATFORM,,}-${version_name,,}.log"

  # Verify OpenCore ISO exists
  iso_file="${OPENCORE_ISO}"
  if [ ! -f "${ISODIR}/$iso_file" ]; then
    display_and_log "OpenCore ISO not found, creating it..." "$logfile"
    update_opencore_iso
  fi

  # Critical: Verify both ISOs exist before proceeding
  if [ ! -f "${ISODIR}/$iso_file" ]; then
    log_and_exit "OpenCore ISO not found at ${ISODIR}/$iso_file" "$logfile"
  fi
  local recovery_iso="${ISODIR}/recovery-${version_name,,}.iso"
  if [ ! -f "$recovery_iso" ]; then
    log_and_exit "Recovery ISO not found at $recovery_iso" "$logfile"
  fi

  [[ ! -d "/sys/class/net/$bridge" ]] && log_and_exit "Bridge $bridge does not exist" "$logfile"

  local cpu_args device_args='-device isa-applesmc,osk="ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc" -smbios type=2'
  if [[ "$version_name" =~ ^(Sonoma|Sequoia)$ ]]; then
    device_args="$device_args -device qemu-xhci -device usb-kbd -device usb-tablet -global nec-usb-xhci.msi=off"
  else
    device_args="$device_args -device usb-kbd,bus=ehci.0,port=2 -device usb-mouse,bus=ehci.0,port=3"
  fi
  # CRITICAL: macOS requires vendor=GenuineIntel even on AMD hosts
  # macOS only runs on Intel CPUs - AMD systems must spoof Intel vendor ID
  # The vendor string tells macOS what CPU vendor it sees, not physical hardware
  # AMD hosts use AMD-specific CPU models (Penryn/Cascadelake) but report as Intel
  if [[ "$OSX_PLATFORM" == "AMD" ]]; then
    if [[ "$version_name" =~ ^(Ventura|Sonoma|Sequoia)$ ]]; then
      cpu_args="-cpu Cascadelake-Server,vendor=GenuineIntel,+invtsc,-pcid,-hle,-rtm,-avx512f,-avx512dq,-avx512cd,-avx512bw,-avx512vl,-avx512vnni,kvm=on,vmware-cpuid-freq=on"
    else
      cpu_args="-cpu Penryn,kvm=on,vendor=GenuineIntel,+kvm_pv_unhalt,+kvm_pv_eoi,+hypervisor,+invtsc,+ssse3,+sse4.2,+popcnt,+avx,+avx2,+aes,+fma,+bmi1,+bmi2,+xsave,+xsaveopt,check"
    fi
  else
    cpu_args="-cpu host,kvm=on,vendor=GenuineIntel,+kvm_pv_unhalt,+kvm_pv_eoi,+hypervisor,+invtsc"
  fi

  # Check QEMU version and append hotplug fix if 6.1 or newer
  # Required for Proxmox 8.4+ with QEMU 6.1+ / Proxmox 9.x with QEMU 10.x
  # Machine version 6.1+ enables ACPI hotplug on PCI bridges by default, which breaks macOS
  local qemu_version=$(qemu-system-x86_64 --version | awk '/version/ {print $4}' | cut -d'(' -f1)
  version_compare "$qemu_version" "6.1" && device_args="$device_args -global ICH9-LPC.acpi-pci-hotplug-with-bridge-support=off"

  # Create VM without ISOs (will import both OpenCore and Recovery as disks)
  # Proxmox 9.x with QEMU 10.x requires both ISOs to be proper disk images, not media=cdrom
  # OpenCore cannot detect ISO files with media=cdrom parameter
  qm create "$vm_id" \
    --agent 1 --args "$device_args $cpu_args" --autostart 0 \
    --balloon 0 --bios ovmf --boot "order=ide0;$disk_type" \
    --cores "$core_count" --description "Hackintosh VM - $version_name" \
    --efidisk0 "${storage}:1,efitype=4m,pre-enrolled-keys=0" --machine q35 --memory "$ram_size" \
    --name "$vm_name" --net0 "vmxnet3,bridge=$bridge" --numa 0 \
    --onboot 0 --ostype other --sockets 1 --start 0 --tablet 1 \
    --vga vmware --vmgenid 1 --scsihw virtio-scsi-pci \
    --"$disk_type" "${storage}:${disk_size},cache=none,discard=on" >>"$logfile" 2>&1 || log_and_exit "Failed to create VM" "$logfile"

  # CRITICAL: Import OpenCore ISO as a disk image for QEMU 10.x compatibility
  # QEMU 10.x cannot boot ISOs with media=disk, and media=cdrom makes them unbootable
  # Solution: Import the ISO as a raw disk image, then attach it
  display_and_log "Importing OpenCore as disk image..." "$logfile"

  local opencore_iso_path="${ISODIR}/${iso_file}"
  qm importdisk "$vm_id" "$opencore_iso_path" "$storage" --format raw >>"$logfile" 2>&1 || log_and_exit "Failed to import OpenCore disk" "$logfile"

  # Find the imported OpenCore disk (will be unusedN in config)
  local vm_conf="/etc/pve/qemu-server/${vm_id}.conf"
  local unused_disk=$(grep "^unused" "$vm_conf" | head -1 | cut -d':' -f1)
  local disk_path=$(grep "^$unused_disk" "$vm_conf" | cut -d' ' -f2)

  if [[ -z "$disk_path" ]]; then
    log_and_exit "Failed to find imported OpenCore disk" "$logfile"
  fi

  # Attach imported OpenCore disk to ide0 and remove from unused
  # CRITICAL: media=disk required for QEMU 10.x - OpenCore cannot boot from media=cdrom
  # CRITICAL: OpenCore disk now contains BOTH bootloader (EFI/OC/) AND recovery (com.apple.recovery.boot/)
  # No separate ide2 recovery disk needed - all files are on ide0
  qm set "$vm_id" -ide0 "$disk_path,cache=unsafe,media=disk" >>"$logfile" 2>&1 || log_and_exit "Failed to attach OpenCore disk" "$logfile"
  qm set "$vm_id" -delete "$unused_disk" >>"$logfile" 2>&1 || log_and_exit "Failed to remove unused disk entry" "$logfile"

  display_and_log "OpenCore disk attached to ide0 (contains bootloader + recovery files)" "$logfile"

  echo -e "${COLOR_GREEN}✓ VM ($vm_name) created successfully${COLOR_RESET}"
  display_and_log "VM ($vm_name) created successfully" "$logfile"
  local bridge_ip=$(ip -4 addr show "$bridge" | awk '/inet/ {print $2}' | cut -d'/' -f1 || echo "unknown")
  if [[ "$version_name" =~ "High Sierra" ]]; then
    display_and_log "\nNOTE: High Sierra has a 'The Recovery Server Could Not Be Contacted' Error!\n - Goto https://mrmacintosh.com/how-to-fix-the-recovery-server-could-not-be-contacted-error-high-sierra-recovery-is-still-online-but-broken/ and do the Fix #3\n\n" "$logfile"
  fi
  display_and_log "Access Proxmox Web Panel: https://$bridge_ip:8006" "$logfile"
}

# Function to add Proxmox VE no-subscription repository
add_no_subscription_repo() {
  local logfile="${LOGDIR}/add-repo-pve-no-subscription.log"
  if pveversion | grep -q "pve-manager/[7]"; then
    printf "deb http://download.proxmox.com/debian/pve bullseye pve-no-subscription\n" > /etc/apt/sources.list.d/pve-no-sub.list
  elif pveversion | grep -q "pve-manager/[8]"; then
    printf "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription\n" > /etc/apt/sources.list.d/pve-no-sub.list
  elif pveversion | grep -q "pve-manager/[9]"; then
    printf "Types: deb\nURIs: http://download.proxmox.com/debian/pve\nSuites: trixie\nComponents: pve-no-subscription\nSigned-By: /usr/share/keyrings/proxmox-archive-keyring.gpg\n" > /etc/apt/sources.list.d/pve-no-sub.sources
  else
    log_and_exit "Unsupported Proxmox version" "$logfile"
  fi
  apt update -y >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
  display_and_log "Repository added successfully" "$logfile"
  pause_for_menu_return
}

# Cleaned function to update the SMBIOS in the OpenCore ISO
update_opencore_smbios() {
  local iso_path=$1 oc_json_path=$2
  local logfile="${LOGDIR}/update-opencore-smbios.log"
  ensure_xmlstarlet_dependency
  ensure_base64_xxd_dependency "$logfile"
  ensure_jq_dependency

  if [[ ! -f "$oc_json_path" ]]; then
    read -rp "No Serial number generated. Do you want to generate a unique serial number? [Y/n]: " GENSMBIOS
    if [[ "${GENSMBIOS:-Y}" =~ ^[Yy]$ ]]; then
      SystemProductName="iMacPro1,1"
      read -e -p "Enter System Product Name (press Enter to keep current): " -i "$SystemProductName" new_value
        if value_changed "$new_value" "$SystemProductName"; then
          SystemProductName="$new_value"
        fi

      # Validate SystemProductName to prevent command injection
      if [[ ! "$SystemProductName" =~ ^[a-zA-Z0-9,._-]+$ ]]; then
        log_and_exit "Invalid SystemProductName format: $SystemProductName (must be alphanumeric with , . _ -)" "$logfile"
      fi

      python3 "$SCRIPT_DIR"/tools/GenSMBIOS/GenSMBIOS.py --install
      python3 "$SCRIPT_DIR"/tools/GenSMBIOS/GenSMBIOS.py --generate "$SystemProductName" -j "$oc_json_path" >>"$logfile" 2>&1 || log_and_exit "Failed to generate SMBIOS" "$logfile"
    else
      display_and_log "Skipping SMBIOS generation" "$logfile"
      return
    fi
  fi

  local loopdev=$(losetup -f --show -P "$iso_path") || log_and_exit "Failed to set up loop device" "$logfile"
  mkdir -p /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"

  # Auto-detect partition structure (handles different OpenCore ISO formats)
  local partition="${loopdev}p1"
  if [ ! -b "$partition" ]; then
    # Try without partition number (direct filesystem)
    partition="$loopdev"
  fi
  mount "$partition" /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to mount ISO" "$logfile"

  # Auto-detect config.plist path (handles different OpenCore structures)
  local config
  if [ -f "/mnt/opencore/EFI/OC/config.plist" ]; then
    config="/mnt/opencore/EFI/OC/config.plist"
  elif [ -f "/mnt/opencore/EFI/BOOT/config.plist" ]; then
    config="/mnt/opencore/EFI/BOOT/config.plist"
  else
    config=$(find /mnt/opencore -name "config.plist" -type f 2>/dev/null | head -1)
    [ -z "$config" ] && log_and_exit "Cannot find config.plist in OpenCore ISO" "$logfile"
  fi
  [[ ! -e "$config.backup" ]] && cp "$config" "$config.backup" >>"$logfile" 2>&1

  # Temporary file
  local TEMP_FILE="${config}.tmp"
  cp "$config" "$TEMP_FILE"

  # Define base XPaths
  local nvram_xpath="//key[text()='NVRAM']/following-sibling::dict/key[text()='Add']/following-sibling::dict/key[text()='7C436110-AB2A-4BBB-A880-FE41995C9F82']/following-sibling::dict"
  local platform_generic_xpath="//key[text()='PlatformInfo']/following-sibling::dict/key[text()='Generic']/following-sibling::dict"

  # Function to read a value from plist
  read_plist_value() {
    xmlstarlet sel -t -v "${2}/key[text()='${3}']/following-sibling::*[1]" "$1" 2>/dev/null
  }

  # Function to update a value in plist
  update_plist_value() {
    xmlstarlet ed -L -u "${2}/key[text()='${3}']/following-sibling::*[1]" -v "$4" "$1"
  }

  # Load and apply JSON values
  declare -A json_values
  json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
  json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
  json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
  json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
  json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")  # HEX

  updated=false
  for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
    if [ -n "${json_values[$key]}" ]; then
      if [ "$key" == "ROM" ]; then
        if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
          modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
        else
          display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
          continue
        fi
      else
        modified_value="${json_values[$key]}"
      fi
      update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
      display_and_log "Updated $key from JSON." "$logfile"
      updated=true
    fi
  done

  # Automatic boot-args adjustment
  system_product_name=$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")
  boot_args=$(read_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args")
  flag=" -nehalem_error_disable"

  if [ "$system_product_name" = "MacPro5,1" ]; then
    if [[ ! "$boot_args" =~ $flag ]]; then
      new_boot_args="$boot_args$flag"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically added '$flag' to boot-args." "$logfile"
      updated=true
    fi
  else
    if [[ "$boot_args" =~ $flag ]]; then
      new_boot_args="${boot_args//$flag/}"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically removed '$flag' from boot-args." "$logfile"
      updated=true
    fi
  fi

  if $updated; then
    display_and_log "Differences between original and modified file (unified format):" "$logfile"
    xmlstarlet fo "$config" > "$config.fmt" || log_and_exit "Failed to format original file" "$logfile"
    diff -u "$config.fmt" "$TEMP_FILE" || true
    rm "$config.fmt"

    read -p "Do you want to apply these changes to the original file? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      mv "$TEMP_FILE" "$config"
      display_and_log "Changes applied to $config" "$logfile"
    else
      display_and_log "Changes discarded." "$logfile"
      rm "$TEMP_FILE"
    fi
  else
    display_and_log "No updates needed from JSON." "$logfile"
    rm "$TEMP_FILE"
  fi

  # Cleanup
  umount /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to unmount ISO" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"
}

# Cleaned function to customize OpenCore config.plist
customize_opencore_config() {
  local oc_json_path iso logfile="${LOGDIR}/custom-oc-config.plist.log"
  iso="${ISODIR}/${OPENCORE_ISO}"
  oc_json_path="${ISODIR}/.smbios.json"
  ensure_xmlstarlet_dependency
  ensure_base64_xxd_dependency "$logfile"
  ensure_jq_dependency

  local loopdev=$(losetup -f --show -P "$iso") || log_and_exit "Failed to set up loop device" "$logfile"
  mkdir -p /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"

  # Auto-detect partition structure (handles different OpenCore ISO formats)
  local partition="${loopdev}p1"
  if [ ! -b "$partition" ]; then
    # Try without partition number (direct filesystem)
    partition="$loopdev"
  fi
  mount "$partition" /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to mount ISO" "$logfile"

  # Auto-detect config.plist path (handles different OpenCore structures)
  local config
  if [ -f "/mnt/opencore/EFI/OC/config.plist" ]; then
    config="/mnt/opencore/EFI/OC/config.plist"
  elif [ -f "/mnt/opencore/EFI/BOOT/config.plist" ]; then
    config="/mnt/opencore/EFI/BOOT/config.plist"
  else
    config=$(find /mnt/opencore -name "config.plist" -type f 2>/dev/null | head -1)
    [ -z "$config" ] && log_and_exit "Cannot find config.plist in OpenCore ISO" "$logfile"
  fi
  [[ ! -e "$config.backup" ]] && cp "$config" "$config.backup" >>"$logfile" 2>&1

  # Temporary file
  local TEMP_FILE="${config}.tmp"
  cp "$config" "$TEMP_FILE"

  # Define base XPaths
  local nvram_xpath="//key[text()='NVRAM']/following-sibling::dict/key[text()='Add']/following-sibling::dict/key[text()='7C436110-AB2A-4BBB-A880-FE41995C9F82']/following-sibling::dict"
  local misc_boot_xpath="//key[text()='Misc']/following-sibling::dict/key[text()='Boot']/following-sibling::dict"
  local platform_generic_xpath="//key[text()='PlatformInfo']/following-sibling::dict/key[text()='Generic']/following-sibling::dict"

  # Define keys and sections
  declare -A key_sections=( ["boot-args"]="nvram" ["csr-active-config"]="nvram" ["prev-lang:kbd"]="nvram" ["Timeout"]="misc_boot" ["MLB"]="platform_generic" ["SystemProductName"]="platform_generic" ["SystemSerialNumber"]="platform_generic" ["SystemUUID"]="platform_generic" ["ROM"]="platform_generic" )
  keys=("boot-args" "csr-active-config" "prev-lang:kbd" "Timeout" "MLB" "SystemProductName" "SystemSerialNumber" "SystemUUID" "ROM")

  # Function to read a value from plist
  read_plist_value() {
    xmlstarlet sel -t -v "${2}/key[text()='${3}']/following-sibling::*[1]" "$1" 2>/dev/null
  }

  # Function to update a value in plist
  update_plist_value() {
    xmlstarlet ed -L -u "${2}/key[text()='${3}']/following-sibling::*[1]" -v "$4" "$1"
  }

  # Function to remove a key from plist
  remove_plist_key() {
    local key_xpath="${2}/key[text()='${3}']"
    local value_xpath="${2}/key[text()='${3}']/following-sibling::*[1]"
    xmlstarlet ed -L -d "$key_xpath" -d "$value_xpath" "$1" || log_and_exit "Failed to remove $3" "$logfile"
  }

  # Integrate JSON logic
  generate_new=false
  if [ -f "$oc_json_path" ]; then
    read -rp "Existing SMBIOS JSON found. Do you want to generate a new serial number? [y/N]: " GENSMBIOS
    if [[ "${GENSMBIOS}" =~ ^[Yy]$ ]]; then
      generate_new=true
    else
      # Apply existing JSON
      declare -A json_values
      json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
      json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
      json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
      json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
      json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")
      for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
        if [ -n "${json_values[$key]}" ]; then
          if [ "$key" == "ROM" ]; then
            if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
              modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
            else
              display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
              continue
            fi
          else
            modified_value="${json_values[$key]}"
          fi
          update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
          display_and_log "Applied $key from existing JSON to temp file." "$logfile"
        fi
      done
    fi
  else
    read -rp "No Serial number generated. Do you want to generate a unique serial number? [Y/n]: " GENSMBIOS
    if [[ "${GENSMBIOS:-Y}" =~ ^[Yy]$ ]]; then
      generate_new=true
    fi
  fi

  # Generate new SMBIOS if requested
  if $generate_new; then
    SystemProductName="$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")"
    read -e -p "Enter System Product Name (press Enter to keep current): " -i "$SystemProductName" new_value
      if value_changed "$new_value" "$SystemProductName"; then
        SystemProductName="$new_value"
      fi

    # Validate SystemProductName to prevent command injection
    if [[ ! "$SystemProductName" =~ ^[a-zA-Z0-9,._-]+$ ]]; then
      log_and_exit "Invalid SystemProductName format: $SystemProductName (must be alphanumeric with , . _ -)" "$logfile"
    fi

    python3 "$SCRIPT_DIR"/tools/GenSMBIOS/GenSMBIOS.py --install
    python3 "$SCRIPT_DIR"/tools/GenSMBIOS/GenSMBIOS.py --generate "$SystemProductName" -j "$oc_json_path" >>"$logfile" 2>&1 || log_and_exit "Failed to generate SMBIOS" "$logfile"
    # Apply new JSON
    declare -A json_values
    json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
    json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
    json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
    json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
    json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")
    for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
      if [ -n "${json_values[$key]}" ]; then
        if [ "$key" == "ROM" ]; then
          if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
            modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
          else
            display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
            continue
          fi
        else
          modified_value="${json_values[$key]}"
        fi
        update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
        display_and_log "Applied new $key from generated JSON to temp file." "$logfile"
      fi
    done
  fi

  # Prompt for edits
  declare -A modified
  for key in "${keys[@]}"; do
    local section=${key_sections[$key]}
    local base_xpath
    case $section in
      nvram) base_xpath="$nvram_xpath" ;;
      misc_boot) base_xpath="$misc_boot_xpath" ;;
      platform_generic) base_xpath="$platform_generic_xpath" ;;
    esac
    value=$(read_plist_value "$TEMP_FILE" "$base_xpath" "$key")
    if [ -z "$value" ]; then
      display_and_log "Warning: Could not read value for $key" "$logfile"
      continue
    fi

    if [ "$key" == "csr-active-config" ]; then
      current_value="$value"
      echo "Current value for $key: $current_value"
      read -rp "Remove csr-active-config (unlock SIP)? [Y/N] [N]: " RM_CSR_LOCK
      if [[ "${RM_CSR_LOCK:-N}" =~ ^[Yy]$ ]]; then
        modified[$key]="remove"
        display_and_log "SIP unlocked. Use 'csrutil disable' in Recovery OS" "$logfile"
        continue
      fi
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if value_changed "$new_value" "$current_value"; then
        modified[$key]="$new_value"
      fi
    elif [ "$key" == "ROM" ]; then
      rom_convert=false
      if command -v base64 >/dev/null && command -v xxd >/dev/null; then
        rom_convert=true
        current_value=$(echo -n "$value" | base64 -d | xxd -p -c 999 | tr -d '\n' | tr 'a-f' 'A-F')
      else
        current_value="$value"
      fi
      echo "Current value for $key (${rom_convert:+HEX}base64 if not): $current_value"
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if value_changed "$new_value" "$current_value"; then
        if $rom_convert; then
          modified[$key]=$(echo -n "$new_value" | xxd -r -p | base64)
        else
          modified[$key]="$new_value"
        fi
      fi
    else
      current_value="$value"
      echo "Current value for $key: $current_value"
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if value_changed "$new_value" "$current_value"; then
        modified[$key]="$new_value"
      fi
    fi
  done

  # Apply user modifications
  if [ ${#modified[@]} -gt 0 ]; then
    display_and_log "Applying user changes to temporary file..." "$logfile"
    for key in "${!modified[@]}"; do
      local section=${key_sections[$key]}
      local base_xpath
      case $section in
        nvram) base_xpath="$nvram_xpath" ;;
        misc_boot) base_xpath="$misc_boot_xpath" ;;
        platform_generic) base_xpath="$platform_generic_xpath" ;;
      esac
      if [ "${modified[$key]}" == "remove" ]; then
        remove_plist_key "$TEMP_FILE" "$base_xpath" "$key"
      else
        update_plist_value "$TEMP_FILE" "$base_xpath" "$key" "${modified[$key]}"
      fi
    done
  fi

  # Automatic boot-args adjustment
  system_product_name=$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")
  boot_args=$(read_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args")
  flag=" -nehalem_error_disable"

  if [ "$system_product_name" = "MacPro5,1" ]; then
    if [[ ! "$boot_args" =~ $flag ]]; then
      new_boot_args="$boot_args$flag"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically added '$flag' to boot-args." "$logfile"
    fi
  else
    if [[ "$boot_args" =~ $flag ]]; then
      new_boot_args="${boot_args//$flag/}"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically removed '$flag' from boot-args." "$logfile"
    fi
  fi

  # Show diff if changes
  xmlstarlet fo "$config" > "$config.fmt"
  local diff_output=$(diff -u "$config.fmt" "$TEMP_FILE")
  rm "$config.fmt"
  if [ -n "$diff_output" ]; then
    display_and_log "Differences between original and modified file (unified format):" "$logfile"
    echo "$diff_output"

    read -rp "Do you want to apply these changes to the original file? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      mv "$TEMP_FILE" "$config"
      display_and_log "Changes applied to $config" "$logfile"

      # Extract and save to JSON
      declare -A extracted
      for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
        val=$(read_plist_value "$config" "$platform_generic_xpath" "$key")
        if [ -z "$val" ]; then
          display_and_log "Warning: Could not read $key from plist." "$logfile"
          continue
        fi
        if [ "$key" == "ROM" ]; then
          if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
            val=$(echo -n "$val" | base64 -d | xxd -p -c 999 | tr -d '\n' | tr 'a-f' 'A-F')
          else
            display_and_log "Warning: base64 or xxd not available. Skipping ROM extraction." "$logfile"
            continue
          fi
        fi
        extracted[$key]="$val"
      done

      jq -n \
        --arg Type "${extracted[SystemProductName]}" \
        --arg Serial "${extracted[SystemSerialNumber]}" \
        --arg board_serial "${extracted[MLB]}" \
        --arg SmUUID "${extracted[SystemUUID]}" \
        --arg ROM "${extracted[ROM]}" \
        '{Type: $Type, Serial: $Serial, "Board Serial": $board_serial, SmUUID: $SmUUID, ROM: $ROM}' > "$oc_json_path"
      display_and_log "Updated/Created SMBIOS JSON at $oc_json_path" "$logfile"
    else
      display_and_log "Changes discarded." "$logfile"
      rm "$TEMP_FILE"
    fi
  else
    display_and_log "No changes were made." "$logfile"
    rm "$TEMP_FILE"
  fi

  # Cleanup
  umount /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to unmount ISO" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"
  display_and_log "OpenCore config customized" "$logfile"
  pause_for_menu_return
}

# Function to update OpenCore ISO
update_opencore_iso() {
  local iso_path
  local logfile="${LOGDIR}/update-opencore-iso.log"

  # CRITICAL: Prevent concurrent execution with file lock
  exec 200>/var/lock/opencore-update.lock
  if ! flock -n 200; then
    log_and_exit "Another OpenCore update is already in progress" "$logfile"
  fi

  # CRITICAL: Use thenickdude's KVM-Opencore v21 for Proxmox 9.x / QEMU 10.x compatibility
  # Generic OpenCore ISOs fail with "LoadImage failed - Unsupported" on QEMU 10.x
  #
  # KVM-Opencore v21 officially supports: Catalina, Big Sur, Monterey, Ventura
  # Tested working: Monterey (confirmed), Ventura (confirmed)
  # Community reports: Sonoma and Sequoia also work with v21 (unofficial/untested)
  #
  # Source: https://github.com/thenickdude/KVM-Opencore/releases/tag/v21
  # Forum: https://forum.proxmox.com/threads/mac-os-15-sequoia-on-proxmox-9-0-3.169742/
  local iso_url="https://github.com/thenickdude/KVM-Opencore/releases/download/v21/OpenCore-v21.iso.gz"
  iso_path="${ISODIR}/${OPENCORE_ISO}"
  oc_json_path="${ISODIR}/.smbios.json"

  # CRITICAL: Backup existing OpenCore-v21.iso before update (enables rollback on failure)
  local backup_path=""
  if [[ -f "$iso_path" ]]; then
    # Validate iso_path is inside ISODIR (prevents path traversal)
    # Portable broken symlink detection (works on Linux and macOS)
    if [[ -L "$iso_path" && ! -e "$iso_path" ]]; then
      log_and_exit "ISO path is broken symlink: $iso_path" "$logfile"
    fi
    if [[ -L "$ISODIR" && ! -e "$ISODIR" ]]; then
      log_and_exit "ISODIR is broken symlink: $ISODIR" "$logfile"
    fi

    local iso_realpath
    if ! iso_realpath=$(readlink -f "$iso_path" 2>>"$logfile"); then
      log_and_exit "Cannot resolve ISO path: $iso_path" "$logfile"
    fi

    local isodir_realpath
    if ! isodir_realpath=$(readlink -f "$ISODIR" 2>>"$logfile"); then
      log_and_exit "Cannot resolve ISODIR: $ISODIR" "$logfile"
    fi

    # Ensure iso_path is under ISODIR (prevent escaping via ../)
    if [[ "$iso_realpath" != "$isodir_realpath"/* ]]; then
      log_and_exit "SECURITY: ISO path outside ISODIR: $iso_realpath" "$logfile"
    fi

    # Create timestamped backup with safe filename
    local timestamp
    if ! timestamp=$(date +%s 2>>"$logfile"); then
      log_and_exit "Failed to generate timestamp for backup" "$logfile"
    fi
    [[ "$timestamp" =~ ^[0-9]+$ ]] || log_and_exit "Invalid timestamp format: $timestamp" "$logfile"
    backup_path="${ISODIR}/OpenCore-v21.iso.backup.${timestamp}"

    if ! cp "$iso_path" "$backup_path" >>"$logfile" 2>&1; then
      log_and_exit "CRITICAL: Cannot create backup (disk full or permission denied)" "$logfile"
    fi
    display_and_log "Created backup: OpenCore-v21.iso.backup.${timestamp}" "$logfile"
  fi

  # Define rollback function to restore backup on failure
  restore_opencore_backup() {
    # Disable EXIT trap to prevent cleanup race condition
    trap - EXIT

    if [[ -n "$backup_path" && -f "$backup_path" ]]; then
      display_and_log "ROLLBACK: Restoring from backup due to update failure..." "$logfile"
      if mv "$backup_path" "$iso_path" >>"$logfile" 2>&1; then
        display_and_log "Backup restored successfully" "$logfile"
      else
        display_and_log "CRITICAL: Backup restore failed! Manual recovery needed at: $backup_path" "$logfile"
      fi
    fi

    # Re-enable EXIT trap for normal cleanup
    trap cleanup EXIT
  }

  # Set trap to auto-rollback on script errors and exit immediately
  trap 'restore_opencore_backup; trap - ERR EXIT; exit 1' ERR

  # CRITICAL: Remove ALL old OpenCore variants to prevent version conflicts
  # This ensures only the correct KVM-Opencore v21 is present
  display_and_log "Cleaning up old OpenCore files..." "$logfile"

  declare -a old_isos=(
    "opencore-osx-proxmox-vm.iso"
    "opencore-autoboot.iso"
    "opencore-original.img"
    "opencore-original.iso"
    "opencore-v21.img"
    "opencore-trumb.iso"
  )

  local removed_count=0
  local skipped_files=()
  local skipped_count=0
  local MAX_SKIPPED_DISPLAY=10
  local lsof_available=false

  # Check lsof availability once
  if command -v lsof >/dev/null 2>&1; then
    lsof_available=true
  else
    display_and_log "WARNING: lsof not available - cannot detect ISOs in use by VMs" "$logfile"
    display_and_log "Install lsof for safer cleanup: apt-get install lsof" "$logfile"
  fi

  if [[ -d "$ISODIR" && -n "$ISODIR" ]]; then
    for iso_name in "${old_isos[@]}"; do
      local iso_file="${ISODIR}/${iso_name}"
      if [[ -f "$iso_file" ]]; then
        # Atomic check-and-delete using flock to prevent TOCTOU race
        if [ "$lsof_available" = true ]; then
          # Use flock for atomic operation (prevents file being opened between check and rm)
          if flock -n "$iso_file" rm -f "$iso_file" >>"$logfile" 2>&1; then
            display_and_log "  Removed: $iso_name" "$logfile"
            ((removed_count++))
          else
            # flock failed = file locked/in-use or permission denied
            if lsof "$iso_file" >/dev/null 2>&1; then
              display_and_log "  WARNING: $iso_name in use by VM - skipping" "$logfile"
              if (( skipped_count < MAX_SKIPPED_DISPLAY )); then
                skipped_files+=("$iso_name (in use)")
              fi
              ((skipped_count++))
            else
              display_and_log "  WARNING: Failed to remove $iso_name" "$logfile"
              if (( skipped_count < MAX_SKIPPED_DISPLAY )); then
                skipped_files+=("$iso_name (permission denied)")
              fi
              ((skipped_count++))
            fi
          fi
        else
          # No lsof - try removal without safety check
          if rm -f "$iso_file" >>"$logfile" 2>&1; then
            display_and_log "  Removed: $iso_name" "$logfile"
            ((removed_count++))
          else
            display_and_log "  WARNING: Failed to remove $iso_name" "$logfile"
            if (( skipped_count < MAX_SKIPPED_DISPLAY )); then
              skipped_files+=("$iso_name (failed)")
            fi
            ((skipped_count++))
          fi
        fi
      fi
    done

    # Remove current OpenCore-v21.iso if exists (will be re-downloaded)
    if [[ -f "$iso_path" ]]; then
      if [ "$lsof_available" = true ] && lsof "$iso_path" >/dev/null 2>&1; then
        log_and_exit "ERROR: ${OPENCORE_ISO} currently in use by VM. Stop VMs before updating." "$logfile"
      fi
      rm -f "$iso_path" >>"$logfile" 2>&1
    fi
  fi

  display_and_log "Cleanup: removed $removed_count old files" "$logfile"
  if (( skipped_count > 0 )); then
    display_and_log "WARNING: Skipped $skipped_count files" "$logfile"
    if (( ${#skipped_files[@]} > 0 )); then
      display_and_log "First $MAX_SKIPPED_DISPLAY: ${skipped_files[*]}" "$logfile"
    fi
    if (( skipped_count > MAX_SKIPPED_DISPLAY )); then
      display_and_log "... and $((skipped_count - MAX_SKIPPED_DISPLAY)) more" "$logfile"
    fi
  fi

  # Ensure gunzip is installed before downloading
  ensure_gunzip_dependency "$logfile"

  # Download compressed ISO with timeout and to temp file first
  local tmp_iso_gz="${iso_path}.tmp.gz"
  if ! wget -q --timeout=300 --tries=3 -O "$tmp_iso_gz" "$iso_url" >>"$logfile" 2>&1; then
    rm -f "$tmp_iso_gz"
    log_and_exit "Failed to download OpenCore ISO from $iso_url" "$logfile"
  fi

  # Verify download completed (minimum size check prevents corrupted/partial downloads)
  local file_size
  file_size=$(wc -c < "$tmp_iso_gz" 2>/dev/null | tr -d ' ' || echo 0)
  if [ "$file_size" -lt "$MIN_COMPRESSED_ISO_SIZE" ]; then  # OpenCore v21.iso.gz should be ~12-15MB
    rm -f "$tmp_iso_gz"
    log_and_exit "Downloaded ISO too small (${file_size} bytes) - likely corrupted or incomplete" "$logfile"
  fi
  display_and_log "Download complete: ${file_size} bytes" "$logfile"

  # Verify SHA256 checksum if sha256sum available (stronger validation than size check)
  if command -v sha256sum >/dev/null 2>&1; then
    # Expected checksum for KVM-Opencore v21.iso.gz
    # Source: https://github.com/thenickdude/KVM-Opencore/releases/tag/v21
    # Updated 2026-01-14: Checksum changed, likely re-release or GitHub CDN update
    local expected_sha256="5ba98fc14f255cea6d19d6a62db3ca1ffe62209b83feb3055331eadb75222387"
    local actual_sha256
    if ! actual_sha256=$(sha256sum "$tmp_iso_gz" 2>>"$logfile" | cut -d' ' -f1); then
      display_and_log "WARNING: Failed to calculate checksum" "$logfile"
      actual_sha256=""
    fi

    if [ "$actual_sha256" != "$expected_sha256" ]; then
      rm -f "$tmp_iso_gz"
      display_and_log "ERROR: ISO checksum verification failed!" "$logfile"
      display_and_log "Expected: $expected_sha256" "$logfile"
      display_and_log "Got:      $actual_sha256" "$logfile"
      display_and_log "This may indicate: corrupted download, MITM attack, or new OpenCore version" "$logfile"
      log_and_exit "Checksum mismatch - refusing to install potentially compromised ISO" "$logfile"
    else
      display_and_log "ISO checksum verified: OK" "$logfile"
    fi
  else
    log_and_exit "sha256sum required for security. Install: apt-get install coreutils" "$logfile"
  fi

  # Decompress the .gz file
  if ! gunzip -f "$tmp_iso_gz" >>"$logfile" 2>&1; then
    rm -f "$tmp_iso_gz" "${tmp_iso_gz%.gz}"
    log_and_exit "Failed to decompress OpenCore ISO" "$logfile"
  fi

  # Verify decompressed ISO exists and has reasonable size
  local tmp_iso="${tmp_iso_gz%.gz}"
  if [ ! -f "$tmp_iso" ]; then
    log_and_exit "Decompressed ISO not found at $tmp_iso" "$logfile"
  fi

  local decompressed_size
  decompressed_size=$(wc -c < "$tmp_iso" 2>/dev/null | tr -d ' ' || echo 0)
  if [ "$decompressed_size" -lt "$MIN_DECOMPRESSED_ISO_SIZE" ]; then  # Should be ~100-150MB decompressed
    rm -f "$tmp_iso"
    log_and_exit "Decompressed ISO too small (${decompressed_size} bytes) - corrupted" "$logfile"
  fi
  display_and_log "Decompression complete: ${decompressed_size} bytes" "$logfile"

  # Move decompressed file to final location
  mv "$tmp_iso" "$iso_path" || log_and_exit "Failed to move OpenCore ISO to $iso_path" "$logfile"

  ensure_base64_xxd_dependency
  update_opencore_smbios "$iso_path" "$oc_json_path"

  # Success! Remove backup and disable rollback trap
  trap - ERR
  if [[ -n "$backup_path" && -f "$backup_path" ]]; then
    rm -f "$backup_path" >>"$logfile" 2>&1
    display_and_log "Update successful - removed backup" "$logfile"
  fi

  display_and_log "OpenCore ISO updated" "$logfile"
  sleep 5
}

# Function to clear recovery images
clear_recovery_images() {
  # Validate paths before deletion
  if [[ -d "$ISODIR" && -n "$ISODIR" ]]; then
    find "$ISODIR" -type f -name "recovery-*.iso" -delete 2>/dev/null
  fi
  if [[ -d "$LOGDIR" && -n "$LOGDIR" ]]; then
    find "$LOGDIR" -type f -name "crt-recovery-*.log" -delete 2>/dev/null
  fi
  display_and_log "All recovery images cleared"
  pause_for_menu_return
}

# Function to remove subscription notice
remove_subscription_notice() {
  echo "DPkg::Post-Invoke { \"if [ -s /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js ] && ! grep -q -F 'NoMoreNagging' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js; then echo 'Removing subscription nag from UI...'; sed -i '/data\.status/{s/\!//;s/active/NoMoreNagging/}' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js; fi\" };" >/etc/apt/apt.conf.d/no-nag-script
  apt --reinstall install proxmox-widget-toolkit &>/dev/null
  display_and_log "Subscription notice removed"
  pause_for_menu_return
}

# Function to configure network bridge
configure_network_bridge() {
  local logfile="${LOGDIR}/configure-network-bridge.log"

  # Logging functions
  die() {
    echo -e "${COLOR_RED}✗ ERROR: $*${COLOR_RESET}"
    display_and_log "ERROR: $*" "$logfile"
    exit 1
  }

  warn() {
    display_and_log "WARNING: $*" "$logfile"
  }

  info() {
    display_and_log "INFO: $*" "$logfile"
  }

  # Restore backup function
  restore_backup() {
    local backup_file="$1"
    info "Restoring network configuration from backup..."
    if [[ -f "$backup_file" ]]; then
      if ! cp "$backup_file" "$NETWORK_INTERFACES_FILE"; then
        die "CRITICAL: Failed to restore network configuration from backup! System may be in unstable state."
      fi
      info "Network configuration successfully restored from backup"
      return 0
    else
      die "CRITICAL: Backup file not found! Network configuration may be corrupted."
    fi
  }

  # Check/create DHCP user group
  ensure_dhcp_group() {
    if ! getent group "$DHCP_USER" >/dev/null; then
      info "Creating DHCP server group '$DHCP_USER'..."
      groupadd "$DHCP_USER" || die "Failed to create group '$DHCP_USER'"
    fi
  }

  # Dependency check
  ensure_dependencies() {
    local deps=("ipcalc")
    local missing=()

    # Check for isc-dhcp-server
    if ! dpkg -l isc-dhcp-server &>/dev/null; then
      deps+=("isc-dhcp-server")
    fi

    for dep in "${deps[@]}"; do
      if ! command -v "$dep" &>/dev/null && ! dpkg -l "$dep" &>/dev/null; then
        missing+=("$dep")
      fi
    done

    if (( ${#missing[@]} > 0 )); then
      info "Installing missing dependencies: ${missing[*]}"
      apt-get update && apt-get install -y "${missing[@]}" >>"$logfile" 2>&1 || die "Failed to install dependencies"
    fi

    # Ensure DHCP config directory exists
    mkdir -p "$DHCP_CONF_DIR"
    chown root:root "$DHCP_CONF_DIR"
    chmod 755 "$DHCP_CONF_DIR"
  }

  # Network calculations
  calculate_network() {
    local subnet=$1
    declare -gA network_info

    # Validate subnet format
    if [[ ! "$subnet" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]]; then
      warn "Invalid subnet format: $subnet"
      return 1
    fi

    # Get ipcalc output
    if ! ipcalc_output=$(ipcalc -nb "$subnet"); then
      warn "ipcalc failed to process subnet: $subnet"
      return 1
    fi

    # Parse network information
    network_info["network"]=$(echo "$ipcalc_output" | awk '/^Network:/ {print $2}' | cut -d'/' -f1)
    network_info["netmask"]=$(echo "$ipcalc_output" | awk '/^Netmask:/ {print $2}')
    network_info["broadcast"]=$(echo "$ipcalc_output" | awk '/^Broadcast:/ {print $2}')
    network_info["hostmin"]=$(echo "$ipcalc_output" | awk '/^HostMin:/ {print $2}')
    network_info["hostmax"]=$(echo "$ipcalc_output" | awk '/^HostMax:/ {print $2}')

    # Calculate DHCP range (skip first 50 IPs)
    IFS='.' read -r i1 i2 i3 i4 <<< "${network_info[hostmin]}"
    network_info["range_start"]="$i1.$i2.$i3.$((i4 + 50))"
    network_info["range_end"]="${network_info[hostmax]}"
    network_info["gateway"]="${network_info[network]%.*}.1"

    # Validate all calculations
    local required=("network" "netmask" "broadcast" "range_start" "range_end" "gateway")
    for key in "${required[@]}"; do
      if [[ -z "${network_info[$key]}" ]]; then
        warn "Failed to calculate network $key for subnet $subnet"
        return 1
      fi
    done
  }

  # Bridge validation
  validate_bridge() {
    local bridge_num=$1
    [[ "$bridge_num" =~ ^[0-9]+$ ]] || { warn "Bridge number must be a positive integer"; return 1; }

    if [[ -d "/sys/class/net/vmbr$bridge_num" || \
          -n $(grep -h "^iface vmbr$bridge_num" "$NETWORK_INTERFACES_FILE" 2>/dev/null) ]]; then
      return 1  # Bridge exists
    fi
    return 0  # Bridge doesn't exist
  }

  # Find next available bridge
  find_next_bridge() {
    local bridge_num=0
    while ! validate_bridge "$bridge_num"; do
      ((bridge_num++))
    done
    echo "$bridge_num"
  }

  # Subnet validation
  validate_subnet() {
    local subnet=$1
    [[ "$subnet" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]] || { warn "Invalid CIDR format"; return 1; }

    IFS='./' read -r ip1 ip2 ip3 ip4 mask <<< "$subnet"
    (( ip1 <= 255 && ip2 <= 255 && ip3 <= 255 && ip4 <= 255 && mask <= 32 )) || { warn "Invalid IP/Netmask"; return 1; }

    # Check for conflicts
    while read -r existing; do
      if [[ -n "$existing" ]]; then
        if ipcalc -n "$subnet" | grep -q "$(ipcalc -n "$existing" | awk -F= '/NETWORK/ {print $2}')"; then
          warn "Subnet conflict detected with $existing"
          return 1
        fi
      fi
    done < <(get_existing_subnets)

    return 0
  }

  get_existing_subnets() {
    grep -h '^iface' "$NETWORK_INTERFACES_FILE" 2>/dev/null | \
    grep -v '^iface lo' | while read -r line; do
      if [[ $line =~ address[[:space:]]+([0-9.]+) ]]; then
        address=${BASH_REMATCH[1]}
        netmask_line=$(grep -A5 "^$line" "$NETWORK_INTERFACES_FILE" 2>/dev/null | grep -m1 'netmask')
        [[ $netmask_line =~ netmask[[:space:]]+([0-9.]+) ]] || continue
        netmask=${BASH_REMATCH[1]}
        cidr=$(ipcalc -p "$address" "$netmask" | awk -F= '/PREFIX/ {print $2}')
        echo "${address}/${cidr}"
      fi
    done
  }

  # Regenerate main dhcpd.conf
  regenerate_dhcpd_conf() {
    # Start with base configuration
    printf "# DHCP Server Configuration\n# Global DHCP options\noption domain-name \"local\";\noption domain-name-servers 8.8.8.8, 8.8.4.4;\n\ndefault-lease-time 604800;\nmax-lease-time 1209600;\n\nauthoritative;\nlog-facility local7;\n" > /etc/dhcp/dhcpd.conf

    # Add includes for all bridge configs
    printf "\n# Bridge configurations\n" >> /etc/dhcp/dhcpd.conf
    for conf in "$DHCP_CONF_DIR"/*.conf; do
      [[ -f "$conf" ]] && printf "include \"%s\";\n" "$conf" >> /etc/dhcp/dhcpd.conf
    done
  }

  # Update DHCP interfaces list
  update_dhcp_interfaces() {
    # Collect all bridge interfaces with DHCP configs
    local interfaces=()
    for conf in "$DHCP_CONF_DIR"/*.conf; do
      [[ -f "$conf" ]] && interfaces+=("$(basename "${conf%.conf}")")
    done

    # Update interfaces list
    printf "INTERFACESv4=\"%s\"\n" "${interfaces[*]}" > /etc/default/isc-dhcp-server
  }

  # DHCP configuration
  configure_dhcp() {
    local bridge_name=$1
    local subnet=$2

    if ! calculate_network "$subnet"; then
      warn "Failed to calculate network parameters for $subnet"
      return 1
    fi

    # Create bridge-specific config
    printf "subnet %s netmask %s {\n" "${network_info[network]}" "${network_info[netmask]}" > "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    range %s %s;\n" "${network_info[range_start]}" "${network_info[range_end]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    option routers %s;\n" "${network_info[gateway]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    option broadcast-address %s;\n" "${network_info[broadcast]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    option subnet-mask %s;\n" "${network_info[netmask]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    default-lease-time 604800;\n" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    max-lease-time 1209600;\n" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "}\n" >> "$DHCP_CONF_DIR/$bridge_name.conf"

    # Set permissions
    chown root:root "$DHCP_CONF_DIR/$bridge_name.conf"
    chmod 644 "$DHCP_CONF_DIR/$bridge_name.conf"

    # Regenerate main config
    regenerate_dhcpd_conf

    # Update interfaces list
    update_dhcp_interfaces

    # Validate config
    if ! dhcpd -t -cf /etc/dhcp/dhcpd.conf >>"$logfile" 2>&1; then
      warn "DHCP configuration validation failed"
      return 1
    fi

    # Restart service
    systemctl restart isc-dhcp-server >>"$logfile" 2>&1 || warn "Failed to restart isc-dhcp-server"
    systemctl enable isc-dhcp-server >>"$logfile" 2>&1
  }

  # Network configuration with rollback support
  configure_network() {
    local bridge_num=$1
    local subnet=$2

    info "Calculating network parameters for $subnet..."
    if ! calculate_network "$subnet"; then
      die "Failed to calculate network parameters for $subnet"
    fi

    local gw_iface=$(ip route | awk '/^default/ {print $5}')
    [[ -z "$gw_iface" ]] && die "No default gateway found"

    # Create backup of interfaces file
    local backup_file="${NETWORK_INTERFACES_FILE}.bak-$(date +%Y%m%d-%H%M%S)"
    info "Creating backup of network interfaces: $backup_file"
    cp "$NETWORK_INTERFACES_FILE" "$backup_file" || die "Failed to create backup of $NETWORK_INTERFACES_FILE"

    # Add bridge configuration
    printf "\n" >> "$NETWORK_INTERFACES_FILE"
    printf "auto vmbr%s\n" "$bridge_num" >> "$NETWORK_INTERFACES_FILE"
    printf "iface vmbr%s inet static\n" "$bridge_num" >> "$NETWORK_INTERFACES_FILE"
    printf "\t# Subnet %s using %s for gateway\n" "$subnet" "$gw_iface" >> "$NETWORK_INTERFACES_FILE"
    printf "\taddress %s\n" "${network_info[gateway]}" >> "$NETWORK_INTERFACES_FILE"
    printf "\tnetmask %s\n" "${network_info[netmask]}" >> "$NETWORK_INTERFACES_FILE"
    printf "\tbridge_ports none\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tbridge_stp off\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tbridge_fd 0\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tpost-up echo 1 > /proc/sys/net/ipv4/ip_forward\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tpost-up iptables -t nat -A POSTROUTING -s '%s' -o %s -j MASQUERADE\n" "$subnet" "$gw_iface" >> "$NETWORK_INTERFACES_FILE"
    printf "\tpost-down iptables -t nat -D POSTROUTING -s '%s' -o %s -j MASQUERADE\n" "$subnet" "$gw_iface" >> "$NETWORK_INTERFACES_FILE"

    # Verify the config was added correctly
    if ! grep -q "iface vmbr$bridge_num inet static" "$NETWORK_INTERFACES_FILE"; then
      warn "Failed to add bridge configuration"
      restore_backup "$backup_file"
      die "Network configuration failed"
    fi

    # Bring up bridge with rollback on failure
    info "Bringing up bridge vmbr$bridge_num..."
    if ! ifup "vmbr$bridge_num" >>"$logfile" 2>&1; then
      warn "Failed to activate bridge"
      restore_backup "$backup_file"
      die "Bridge activation failed - configuration rolled back"
    fi

    # Clean up backup if successful
    rm -f "$backup_file"
  }

  # Prompt with validation
  prompt_with_validation() {
    local prompt=$1
    local default=$2
    local validation_func=$3
    local value

    while true; do
      read -rp "$prompt [$default]: " value
      value=${value:-$default}
      if $validation_func "$value"; then
        echo "$value"
        return
      fi
      display_and_log "Press any key to return to the main menu..."
      read -n 1 -s
      return 1
    done
  }

  # Main execution
  info "Configuring network bridge for macOS in Cloud..."

  # Check root
  (( EUID == 0 )) || die "This function must be run as root"

  ensure_dependencies
  ensure_dhcp_group

  # Get bridge number
  local next_bridge=$(find_next_bridge)
  info "Next available bridge: vmbr$next_bridge"
  local bridge_num
  bridge_num=$(prompt_with_validation "Enter bridge number" "$next_bridge" validate_bridge) || return

  # Get subnet
  local default_subnet="10.27.$bridge_num.0/24"
  local subnet
  subnet=$(prompt_with_validation "Enter subnet for VM bridge in CIDR notation" "$default_subnet" validate_subnet) || return

  # Configure network
  info "Configuring network..."
  configure_network "$bridge_num" "$subnet"

  # Configure DHCP
  read -rp "Configure DHCP server for vmbr$bridge_num? [Y/n]: " answer
  if [[ "${answer,,}" =~ ^(y|)$ ]]; then
    info "Configuring DHCP server..."
    configure_dhcp "vmbr$bridge_num" "$subnet" || {
      warn "DHCP configuration failed. Network bridge configured, but DHCP not enabled."
    }
  fi

  info "Configuration completed:"
  info "Bridge: vmbr$bridge_num"
  info "Subnet: $subnet"
  info "Gateway: ${network_info[gateway]}"
  [[ "${answer,,}" =~ ^(y|)$ ]] && info "DHCP Range: ${network_info[range_start]} - ${network_info[range_end]}"
  info "Network config: $NETWORK_INTERFACES_FILE"
  [[ "${answer,,}" =~ ^(y|)$ ]] && info "DHCP config: $DHCP_CONF_DIR/vmbr$bridge_num.conf"
  display_and_log "Press any key to return to the main menu..."
  read -n 1 -s
}

# Function to configure macOS VM
configure_macos_vm() {
  local macopt=$1
  local nextid=$2
  local version_name version board_id model_id iso_size disk_type opt=$3
  IFS='|' read -r version_name version board_id model_id iso_size disk_type <<< "$macopt"
  local default_vm_name="${DEFAULT_VM_PREFIX}$(echo "$version_name" | tr -s ' ' | sed 's/^[ ]*//;s/[ ]*$//;s/[ ]/-/g' | tr '[:lower:]' '[:upper:]' | sed 's/-*$//')"
  validate_vm_name "$default_vm_name" || log_and_exit "Invalid default VM name: $default_vm_name" "${LOGDIR}/main-menu.log"
  clear
  display_and_log "macOS $version_name"

  # VM ID
  while true; do
    read -rp "VM ID [${nextid}]: " VM_ID
    VM_ID=${VM_ID:-$nextid}
    if [[ "$VM_ID" =~ ^[0-9]+$ && ! -e "/etc/pve/qemu-server/$VM_ID.conf" ]]; then
      break
    else
      display_and_log "Invalid or existing VM ID. Please try again."
    fi
  done

  # VM Name
  while true; do
    read -rp "VM Name [${default_vm_name}]: " VM_NAME
    VM_NAME=${VM_NAME:-$default_vm_name}
    if validate_vm_name "$VM_NAME"; then
      break
    else
      display_and_log "Invalid VM name. Please use alphanumeric characters, -, _, .; no spaces."
    fi
  done

  # Disk Size - interactive menu
  default_disk_size=$((BASE_DISK_SIZE + (opt > 6 ? 2 : opt == 4 ? 1 : 0) * DISK_INCREMENT))
  local disk_options=("64 GB" "128 GB (recommended)" "256 GB" "512 GB" "1024 GB (1 TB)")
  local disk_default_idx=1
  [[ $default_disk_size -eq 64 ]] && disk_default_idx=0
  [[ $default_disk_size -eq 128 ]] && disk_default_idx=1
  [[ $default_disk_size -eq 256 ]] && disk_default_idx=2
  [[ $default_disk_size -eq 512 ]] && disk_default_idx=3
  [[ $default_disk_size -eq 1024 ]] && disk_default_idx=4

  if result=$(select_from_menu "Select disk size:" $disk_default_idx "${disk_options[@]}"); then
    SIZEDISK=$(echo "$result" | awk '{print $1}')
  else
    while true; do
      read -rp "Enter disk size (GB) [default: $default_disk_size]: " SIZEDISK
      SIZEDISK=${SIZEDISK:-$default_disk_size}
      if [[ "$SIZEDISK" =~ ^[0-9]+$ ]]; then
        break
      else
        display_and_log "Disk size must be an integer. Please try again."
      fi
    done
  fi

  # Storage Selection - interactive menu
  local storage_output
  if ! storage_output=$(get_available_storages); then
    display_and_log "Failed to retrieve storages"
    read -n 1 -s
    return 1
  fi
  local storages=() default_storage="" storage_options=()
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    [[ -z "$default_storage" && ! "$line" =~ \| ]] && default_storage="$line" || storages+=("$line")
  done <<< "$storage_output"
  if ((${#storages[@]} == 0)); then
    display_and_log "No storages found"; read -n 1 -s; return 1
  fi
  if ((${#storages[@]} == 1)); then
    STORAGECRTVM="${storages[0]%%|*}"
    display_and_log "Using storage: $STORAGECRTVM"
  else
    for s in "${storages[@]}"; do
      storage_name="${s%%|*}"
      avail_space="${s##*|}"
      storage_options+=("$storage_name ($avail_space GB free)")
    done

    if result=$(select_from_menu "Select storage:" 0 "${storage_options[@]}"); then
      STORAGECRTVM=$(echo "$result" | awk '{print $1}')
    else
      while true; do
        read -rp "Enter storage name [${default_storage}]: " STORAGECRTVM
        STORAGECRTVM=${STORAGECRTVM:-$default_storage}
        local valid=false
        for s in "${storages[@]}"; do
          if [[ "$STORAGECRTVM" == "${s%%|*}" ]]; then
            valid=true
            break
          fi
        done
        if $valid; then
          display_and_log "Selected storage: $STORAGECRTVM"
          break
        else
          display_and_log "Invalid storage. Please try again."
        fi
      done
    fi
  fi

  # Bridge Selection - interactive menu
  local bridge_output=$(get_available_bridges) || { display_and_log "Failed to retrieve bridges"; read -n 1 -s; return 1; }
  local bridges=() default_bridge="" bridge_options=()
  while IFS= read -r line; do
    line=$(echo "$line" | tr -d '\r')
    [[ -z "$line" ]] && continue
    if [[ ! "$line" =~ \| ]]; then
      default_bridge="$line"
    else
      bridges+=("$line")
    fi
  done <<< "$bridge_output"
  if ((${#bridges[@]} == 0)); then
    display_and_log "No bridges found"; read -n 1 -s; return 1
  fi

  declare -A bridge_info
  for b in "${bridges[@]}"; do
    IFS='|' read -r bridge_name ip_addr <<< "$b"
    bridge_info["$bridge_name"]="IP: ${ip_addr:-unknown}"
  done

  mapfile -t sorted_names < <(printf '%s\n' "${!bridge_info[@]}" | sort -V)

  local default_bridge_num=${default_bridge#vmbr}
  if ((${#bridges[@]} == 1)); then
    name="${sorted_names[0]}"
    ip_info="${bridge_info[$name]}"
    BRIDGECRTVM="$name"
    display_and_log "Using bridge: $BRIDGECRTVM ($ip_info)"
  else
    for name in "${sorted_names[@]}"; do
      ip_info="${bridge_info[$name]}"
      bridge_options+=("$name ($ip_info)")
    done

    if result=$(select_from_menu "Select network bridge:" 0 "${bridge_options[@]}"); then
      BRIDGECRTVM=$(echo "$result" | awk '{print $1}')
    else
      while true; do
        read -rp "Enter bridge number [${default_bridge_num}]: " BRIDGE_NUM
        BRIDGE_NUM=${BRIDGE_NUM:-$default_bridge_num}
        if [[ "$BRIDGE_NUM" =~ ^[0-9]+$ ]]; then
          BRIDGECRTVM="vmbr$BRIDGE_NUM"
          if [[ -n "${bridge_info[$BRIDGECRTVM]}" ]]; then
            display_and_log "Selected bridge: $BRIDGECRTVM"
            break
          else
            display_and_log "Invalid bridge number. Please try again."
          fi
        else
          display_and_log "Bridge number must be an integer. Please try again."
        fi
      done
    fi
  fi

  # CPU Cores - interactive menu
  local cpu_options=("2 cores" "4 cores (recommended)" "8 cores" "16 cores")
  if result=$(select_from_menu "Select CPU cores:" 1 "${cpu_options[@]}"); then
    PROC_COUNT=$(echo "$result" | awk '{print $1}')
  else
    while true; do
      read -rp "Enter CPU cores (power of 2): " PROC_COUNT
      if [[ "$PROC_COUNT" =~ ^[0-9]+$ ]]; then
        if ! is_power_of_2 "$PROC_COUNT"; then
          PROC_COUNT=$(next_power_of_2 "$PROC_COUNT")
          display_and_log "Adjusted to next power of 2: $PROC_COUNT"
        fi
        break
      else
        display_and_log "CPU cores must be an integer. Please try again."
      fi
    done
  fi
  ((PROC_COUNT > MAX_CORES)) && PROC_COUNT=$MAX_CORES

  # RAM - interactive menu
  local default_ram=$((BASE_RAM_SIZE + PROC_COUNT * RAM_PER_CORE))
  local ram_options=("4096 MiB (4 GB)" "6144 MiB (6 GB - recommended)" "8192 MiB (8 GB)" "16384 MiB (16 GB)" "32768 MiB (32 GB)")
  local ram_default_idx=1
  [[ $default_ram -eq 4096 ]] && ram_default_idx=0
  [[ $default_ram -eq 6144 ]] && ram_default_idx=1
  [[ $default_ram -eq 8192 ]] && ram_default_idx=2
  [[ $default_ram -eq 16384 ]] && ram_default_idx=3
  [[ $default_ram -eq 32768 ]] && ram_default_idx=4

  if result=$(select_from_menu "Select RAM:" $ram_default_idx "${ram_options[@]}"); then
    RAM_SIZE=$(echo "$result" | awk '{print $1}')
  else
    while true; do
      read -rp "Enter RAM (MiB) [$default_ram]: " RAM_SIZE
      RAM_SIZE=${RAM_SIZE:-$default_ram}
      if [[ "$RAM_SIZE" =~ ^[0-9]+$ ]]; then
        break
      else
        display_and_log "RAM must be an integer. Please try again."
      fi
    done
  fi

  # Ensure OpenCore ISO exists before downloading recovery
  if [ ! -f "${ISODIR}/${OPENCORE_ISO}" ]; then
    echo -e "${COLOR_YELLOW}OpenCore ISO not found, downloading...${COLOR_RESET}"
    update_opencore_iso
  fi

  # Recovery Image - check if recovery files already added to OpenCore disk
  local marker_file="${ISODIR}/.recovery-${version_name,,}.done"
  if [[ ! -f "$marker_file" ]]; then
    read -rp "Recovery files not added to OpenCore disk. Download now? [Y/n]: " CRTRECODISK
    if [[ "${CRTRECODISK:-Y}" =~ ^[Yy]$ ]]; then
      download_recovery_image "$version_name" "$board_id" "$model_id" "$iso_size"
    else
      echo -e "${COLOR_RED}✗ ERROR: Cannot create VM without recovery files on OpenCore disk${COLOR_RESET}"
      display_and_log "ERROR: Cannot create VM without recovery files"
      display_and_log "Recovery files must be added to OpenCore disk first"
      pause_for_menu_return
      return
    fi
  else
    echo -e "${COLOR_GREEN}✓ Recovery files already on OpenCore disk${COLOR_RESET}"
    display_and_log "Recovery files found on OpenCore disk"
  fi

  # Verify recovery marker exists before creating VM
  if [[ ! -f "$marker_file" ]]; then
    echo -e "${COLOR_RED}✗ ERROR: Recovery files not found on OpenCore disk${COLOR_RESET}"
    display_and_log "ERROR: Recovery files not added to OpenCore disk"
    display_and_log "VM creation aborted"
    pause_for_menu_return
    return
  fi

  create_vm "$version_name" "$VM_ID" "$VM_NAME" "$SIZEDISK" "$STORAGECRTVM" "$PROC_COUNT" "$RAM_SIZE" "$iso_size" "$disk_type" "$BRIDGECRTVM"
  pause_for_menu_return
}

# Function for main menu loop
main_menu() {
  while true; do
    clear
    NEXTID=$(pvesh get /cluster/nextid)
    echo -e "${COLOR_CYAN}═══════════════════════════════════════════════════════${COLOR_RESET}"
    echo -e "${COLOR_CYAN}            O S X - P R O X M O X                      ${COLOR_RESET}"
    echo -e "${COLOR_GREEN}        Full Proxmox 9.x Support with QEMU 10.x        ${COLOR_RESET}"
    echo -e "${COLOR_CYAN}═══════════════════════════════════════════════════════${COLOR_RESET}"
    echo
    echo -e "${COLOR_YELLOW}Next VM ID: ${NEXTID} │ OpenCore: ${OCVERSION} │ Version: ${HACKPXVERSION}${COLOR_RESET}"
    echo

    # Build menu options arrays
    local macos_options=()
    local macos_keys=()

    # Sort and build macOS version options
    for i in $(for key in "${!MACOS_CONFIG[@]}"; do
      IFS='|' read -r _ version _ _ _ _ <<< "${MACOS_CONFIG[$key]}"
      echo "$version|$key"
    done | sort -t'|' -k1,1V | cut -d'|' -f2); do
      IFS='|' read -r name version _ _ _ _ <<< "${MACOS_CONFIG[$i]}"
      [[ "$name" == "Sequoia" ]] && display_name="macOS Sequoia" || display_name="$name"
      macos_options+=("$display_name ($version)")
      macos_keys+=("$i")
    done

    # Add additional options
    macos_options+=(
      "────────────────────────────────────"
      "Add Proxmox no-subscription repo"
      "Update OpenCore ISO"
      "Clear macOS recovery images"
      "Remove Proxmox subscription notice"
      "Add network bridge"
      "Customize OpenCore config"
      "────────────────────────────────────"
      "Quit"
    )
    macos_keys+=("separator" "200" "201" "202" "203" "204" "205" "separator2" "0")

    # Show interactive menu
    if result=$(select_from_menu "Select option:" 0 "${macos_options[@]}"); then
      # Find index of selected option
      local selected_idx=0
      for idx in "${!macos_options[@]}"; do
        if [[ "${macos_options[$idx]}" == "$result" ]]; then
          selected_idx=$idx
          break
        fi
      done

      local selected_key="${macos_keys[$selected_idx]}"

      # Handle selection
      if [[ "$selected_key" == "separator" || "$selected_key" == "separator2" ]]; then
        continue
      elif [[ "$selected_key" == "0" ]]; then
        exit 0
      elif [[ ${MACOS_CONFIG[$selected_key]} ]]; then
        configure_macos_vm "${MACOS_CONFIG[$selected_key]}" "$NEXTID" "$selected_key"
      else
        case $selected_key in
          200) add_no_subscription_repo ;;
          201) update_opencore_iso ;;
          202) clear_recovery_images ;;
          203) remove_subscription_notice ;;
          204) configure_network_bridge ;;
          205) customize_opencore_config ;;
        esac
      fi
    else
      # Manual input mode
      echo
      echo "Manual input mode:"
      for i in "${!macos_keys[@]}"; do
        local key="${macos_keys[$i]}"
        [[ "$key" == "separator" || "$key" == "separator2" ]] && continue
        echo " $key - ${macos_options[$i]}"
      done
      echo
      read -rp "Option: " OPT
      [[ -z "$OPT" || "$OPT" -eq 0 ]] && exit

      if [[ ${MACOS_CONFIG[$OPT]} ]]; then
        configure_macos_vm "${MACOS_CONFIG[$OPT]}" "$NEXTID" "$OPT"
      else
        case $OPT in
          200) add_no_subscription_repo ;;
          201) update_opencore_iso ;;
          202) clear_recovery_images ;;
          203) remove_subscription_notice ;;
          204) configure_network_bridge ;;
          205) customize_opencore_config ;;
          *) echo "Invalid option"; read -n 1 -s ;;
        esac
      fi
    fi
  done
}

# Main script
clear
init_dirs
check_proxmox_version
set_isodir

# CRITICAL: Determine if OpenCore v21 update needed (prevents double-execution race condition)
# Check for old ISOs OR missing v21 ISO, then update ONCE
needs_opencore_update=false

if [[ -f "${ISODIR}/opencore-osx-proxmox-vm.iso" ]] || \
   [[ -f "${ISODIR}/opencore-autoboot.iso" ]] || \
   [[ -f "${ISODIR}/opencore-original.iso" ]] || \
   [[ -f "${ISODIR}/opencore-original.img" ]] || \
   [[ -f "${ISODIR}/opencore-v21.img" ]] || \
   [[ -f "${ISODIR}/opencore-trumb.iso" ]]; then
  echo "=================================================="
  echo "  WARNING: Old OpenCore ISOs detected!"
  echo "  Forcing update to KVM-Opencore v21..."
  echo "=================================================="
  needs_opencore_update=true
fi

if [ ! -f "${ISODIR}/${OPENCORE_ISO}" ]; then
  [ "$needs_opencore_update" = false ] && echo "OpenCore v21 ISO not found, downloading..."
  needs_opencore_update=true
fi

# Execute update only once if needed
if [ "$needs_opencore_update" = true ]; then
  sleep 2
  update_opencore_iso "0"
fi
sleep 4
OSX_PLATFORM=$(detect_cpu_platform)
[[ ! -e /etc/pve/qemu-server/.osx-proxmox ]] && setup_prerequisites
main_menu
